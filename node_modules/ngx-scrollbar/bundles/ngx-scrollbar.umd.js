(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/bidi'), require('@angular/cdk/portal'), require('@angular/cdk/platform'), require('ngx-scrollbar/smooth-scroll'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/coercion'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('ngx-scrollbar', ['exports', '@angular/core', '@angular/common', '@angular/cdk/bidi', '@angular/cdk/portal', '@angular/cdk/platform', 'ngx-scrollbar/smooth-scroll', 'rxjs', 'rxjs/operators', '@angular/cdk/coercion', '@angular/platform-browser'], factory) :
    (global = global || self, factory(global['ngx-scrollbar'] = {}, global.ng.core, global.ng.common, global.ng.cdk.bidi, global.ng.cdk.portal, global.ng.cdk.platform, global['ngx-scrollbar']['smooth-scroll'], global.rxjs, global.rxjs.operators, global.ng.cdk.coercion, global.ng.platformBrowser));
}(this, function (exports, core, common, bidi, portal, platform, smoothScroll, rxjs, operators, coercion, platformBrowser) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ScrollViewport = /** @class */ (function () {
        function ScrollViewport(viewPort) {
            this.viewPort = viewPort;
        }
        ScrollViewport.decorators = [
            { type: core.Directive, args: [{
                        selector: '[scrollViewport], [scroll-viewport]',
                        host: {
                            '[class.ng-scroll-viewport]': 'true'
                        }
                    },] }
        ];
        /** @nocollapse */
        ScrollViewport.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return ScrollViewport;
    }());
    if (false) {
        /** @type {?} */
        ScrollViewport.prototype.viewPort;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NG_SCROLLBAR_OPTIONS = new core.InjectionToken('NG_SCROLLBAR_OPTIONS');
    /**
     * @record
     */
    function NgScrollbarOptions() { }
    if (false) {
        /**
         * Sets the scroll axis of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar-control
         * - `horizontal` Use both vertical and horizontal scrollbar-control
         * - `all` Use both vertical and horizontal scrollbar-control
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar-control
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar-control.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar-control.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar-control positions
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.position;
        /**
         * A class forwarded to scrollable viewport element
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.viewClass;
        /**
         * A class forwarded to the scrollbar track element
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.trackClass;
        /**
         * A class forwarded to the scrollbar thumb element
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.thumbClass;
        /**
         * The minimum scrollbar thumb size in px
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.minThumbSize;
        /**
         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.trackClickScrollDuration;
        /**
         * A flag used to enable/disable the scrollbar track clicked event
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.trackClickDisabled;
        /**
         * A flag used to enable/disable the scrollbar thumb dragged event
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.thumbDragDisabled;
        /**
         * Debounce interval for detecting changes via window.resize event
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.windowResizeDebounce;
        /**
         * Debounce interval for detecting changes via ResizeObserver
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.sensorDebounce;
        /**
         * Whether ResizeObserver is disabled
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.sensorDisabled;
    }
    /**
     * Set of attributes added on the scrollbar wrapper
     * @record
     */
    function NgScrollbarState() { }
    if (false) {
        /** @type {?|undefined} */
        NgScrollbarState.prototype.position;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.track;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.appearance;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.visibility;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.disabled;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.dir;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.verticalUsed;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.horizontalUsed;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.isVerticallyScrollable;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.isHorizontallyScrollable;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.verticalHovered;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.horizontalHovered;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.verticalDragging;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.horizontalDragging;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var defaultOptions = {
        viewClass: '',
        trackClass: '',
        thumbClass: '',
        track: 'vertical',
        appearance: 'compact',
        visibility: 'native',
        position: 'native',
        thumbDragDisabled: false,
        trackClickDisabled: false,
        trackClickScrollDuration: 300,
        minThumbSize: 20,
        windowResizeDebounce: 0,
        sensorDebounce: 0,
        sensorDisabled: false
    };
    var ScrollbarManager = /** @class */ (function () {
        function ScrollbarManager(options) {
            this.globalOptions = options ? __assign({}, defaultOptions, options) : defaultOptions;
            this.rtlScrollAxisType = platform.getRtlScrollAxisType();
        }
        ScrollbarManager.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        ScrollbarManager.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }
        ]; };
        /** @nocollapse */ ScrollbarManager.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(core.ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: "root" });
        return ScrollbarManager;
    }());
    if (false) {
        /** @type {?} */
        ScrollbarManager.prototype.globalOptions;
        /** @type {?} */
        ScrollbarManager.prototype.rtlScrollAxisType;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NativeScrollbarSizeFactory = /** @class */ (function () {
        function NativeScrollbarSizeFactory(document, manager, platform) {
            var _this = this;
            this.document = document;
            this.manager = manager;
            this.platform = platform;
            if (platform.isBrowser) {
                rxjs.of(null).pipe(operators.tap((/**
                 * @return {?}
                 */
                function () { return _this._nativeScrollbarSize = new rxjs.BehaviorSubject(_this.getNativeScrollbarSize()); })), operators.tap((/**
                 * @return {?}
                 */
                function () { return _this.nativeScrollbarSize = _this._nativeScrollbarSize.asObservable(); })), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return rxjs.fromEvent(_this.document.defaultView, 'resize', { passive: true }); })), operators.debounceTime(this.manager.globalOptions.windowResizeDebounce), operators.tap((/**
                 * @return {?}
                 */
                function () { return _this._nativeScrollbarSize.next(_this.getNativeScrollbarSize()); }))).subscribe();
            }
        }
        /**
         * Get native scrollbar size
         */
        /**
         * Get native scrollbar size
         * @private
         * @return {?}
         */
        NativeScrollbarSizeFactory.prototype.getNativeScrollbarSize = /**
         * Get native scrollbar size
         * @private
         * @return {?}
         */
        function () {
            if (this.platform.ANDROID || this.platform.IOS) {
                return 6;
            }
            /** @type {?} */
            var box = this.document.createElement('div');
            box.className = 'ng-scrollbar-measure';
            this.document.body.appendChild(box);
            /** @type {?} */
            var size = box.getBoundingClientRect().right;
            this.document.body.removeChild(box);
            // if size is 0, return 15 (for MAC OS browsers)
            return size || 15;
        };
        NativeScrollbarSizeFactory.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        NativeScrollbarSizeFactory.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: ScrollbarManager },
            { type: platform.Platform }
        ]; };
        /** @nocollapse */ NativeScrollbarSizeFactory.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(core.ɵɵinject(common.DOCUMENT), core.ɵɵinject(ScrollbarManager), core.ɵɵinject(platform.Platform)); }, token: NativeScrollbarSizeFactory, providedIn: "root" });
        return NativeScrollbarSizeFactory;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype._nativeScrollbarSize;
        /** @type {?} */
        NativeScrollbarSizeFactory.prototype.nativeScrollbarSize;
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype.document;
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype.manager;
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype.platform;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgScrollbar = /** @class */ (function () {
        function NgScrollbar(el, zone, changeDetectorRef, dir, smoothScroll, manager, nativeScrollbarSizeFactory) {
            this.el = el;
            this.zone = zone;
            this.changeDetectorRef = changeDetectorRef;
            this.dir = dir;
            this.smoothScroll = smoothScroll;
            this.manager = manager;
            this.nativeScrollbarSizeFactory = nativeScrollbarSizeFactory;
            /**
             * A class forwarded to scrollable viewport element
             */
            this.viewClass = this.manager.globalOptions.viewClass;
            /**
             * A class forwarded to the scrollbar track element
             */
            this.trackClass = this.manager.globalOptions.trackClass;
            /**
             * A class forwarded to the scrollbar thumb element
             */
            this.thumbClass = this.manager.globalOptions.thumbClass;
            /**
             * Minimum scrollbar thumb size
             */
            this.minThumbSize = this.manager.globalOptions.minThumbSize;
            /**
             * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
             */
            this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;
            /**
             * A flag used to enable/disable the scrollbar track clicked event
             */
            this.trackClickDisabled = this.manager.globalOptions.trackClickDisabled;
            /**
             * A flag used to enable/disable the scrollbar thumb dragged event
             */
            this.thumbDragDisabled = this.manager.globalOptions.thumbDragDisabled;
            /**
             * Disable custom scrollbar and switch back to native scrollbar
             */
            this.disabled = false;
            /**
             * Sets the supported scroll track of the viewport, there are 3 options:
             *
             * - `vertical` Use both vertical and horizontal scrollbar
             * - `horizontal` Use both vertical and horizontal scrollbar
             * - `all` Use both vertical and horizontal scrollbar
             */
            this.track = this.manager.globalOptions.track;
            /**
             * When to show the scrollbar, and there are 3 options:
             *
             * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
             * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
             * - `always` Scrollbars are always shown even if the viewport is not scrollable
             */
            this.visibility = this.manager.globalOptions.visibility;
            /**
             *  Sets the appearance of the scrollbar, there are 2 options:
             *
             * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
             * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
             */
            this.appearance = this.manager.globalOptions.appearance;
            /**
             * Sets the position of each scrollbar, there are 4 options:
             *
             * - `native` (Default) Use the default position like in native scrollbar.
             * - `invertY` Inverts vertical scrollbar position
             * - `invertX` Inverts Horizontal scrollbar position
             * - `invertAll` Inverts both scrollbar positions
             */
            this.position = this.manager.globalOptions.position;
            /**
             * Debounce interval for detecting changes via ResizeObserver
             */
            this.sensorDebounce = this.manager.globalOptions.sensorDebounce;
            /**
             * Whether ResizeObserver is disabled
             */
            this.sensorDisabled = this.manager.globalOptions.sensorDisabled;
            /**
             * Steam that emits when scrollbar is updated
             */
            this.updated = new core.EventEmitter();
            /**
             * Set of attributes added on the scrollbar wrapper
             */
            this.state = {};
            /**
             * Stream that destroys components' observables
             */
            this.destroyed = new rxjs.Subject();
        }
        /**
         * @private
         * @param {?} track
         * @return {?}
         */
        NgScrollbar.prototype.getScrolledByDirection = /**
         * @private
         * @param {?} track
         * @return {?}
         */
        function (track) {
            /** @type {?} */
            var scrollProperty = track === 'vertical' ? 'scrollTop' : 'scrollLeft';
            /** @type {?} */
            var event;
            return this.scrolled.pipe(operators.tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return event = e; })), operators.pluck('target', scrollProperty), operators.pairwise(), operators.filter((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                return prev !== curr;
            })), operators.map((/**
             * @return {?}
             */
            function () { return event; })));
        };
        /**
         * Update local state with each change detection
         */
        /**
         * Update local state with each change detection
         * @private
         * @return {?}
         */
        NgScrollbar.prototype.updateState = /**
         * Update local state with each change detection
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var verticalUsed = false;
            /** @type {?} */
            var horizontalUsed = false;
            /** @type {?} */
            var isVerticallyScrollable = false;
            /** @type {?} */
            var isHorizontallyScrollable = false;
            // Check if vertical scrollbar should be displayed
            if (this.track === 'all' || this.track === 'vertical') {
                isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;
                verticalUsed = this.visibility === 'always' || isVerticallyScrollable;
            }
            // Check if horizontal scrollbar should be displayed
            if (this.track === 'all' || this.track === 'horizontal') {
                isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;
                horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;
            }
            this._updateState({
                position: this.position,
                track: this.track,
                appearance: this.appearance,
                visibility: this.visibility,
                disabled: this.disabled,
                dir: this.dir.value,
                verticalUsed: verticalUsed,
                horizontalUsed: horizontalUsed,
                isVerticallyScrollable: isVerticallyScrollable,
                isHorizontallyScrollable: isHorizontallyScrollable
            });
        };
        /**
         * @private
         * @param {?} state
         * @return {?}
         */
        NgScrollbar.prototype._updateState = /**
         * @private
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.state = __assign({}, this.state, state);
            this.changeDetectorRef.detectChanges();
        };
        /**
         * @param {?} hovered
         * @return {?}
         */
        NgScrollbar.prototype.setHovered = /**
         * @param {?} hovered
         * @return {?}
         */
        function (hovered) {
            var _this = this;
            this.zone.run((/**
             * @return {?}
             */
            function () { return _this._updateState(__assign({}, hovered)); }));
        };
        /**
         * @param {?} dragging
         * @return {?}
         */
        NgScrollbar.prototype.setDragging = /**
         * @param {?} dragging
         * @return {?}
         */
        function (dragging) {
            var _this = this;
            this.zone.run((/**
             * @return {?}
             */
            function () { return _this._updateState(__assign({}, dragging)); }));
        };
        /**
         * Set the viewport based on user choice
         */
        /**
         * Set the viewport based on user choice
         * @private
         * @return {?}
         */
        NgScrollbar.prototype.setViewport = /**
         * Set the viewport based on user choice
         * @private
         * @return {?}
         */
        function () {
            var _a;
            if (this.customViewPort) {
                // Set the custom viewport as the scroll viewport
                this.viewport = this.customViewPort.viewPort.nativeElement;
                // In this case the default viewport and the default content wrapper will act as a mask
                this.viewportClasses = {
                    'ng-scroll-offset': true,
                    'ng-scroll-layer': true
                };
                this.defaultViewPort.nativeElement.firstElementChild.className = 'ng-scroll-layer';
            }
            else {
                // Set the default viewport as the scroll viewport
                this.viewport = this.defaultViewPort.nativeElement;
                this.viewportClasses = (_a = {
                        'ng-scroll-offset': true,
                        'ng-scroll-viewport': true
                    },
                    _a[this.viewClass] = true,
                    _a);
            }
            // Check if the custom viewport has only one child and set it as the content wrapper
            if (this.viewport.firstElementChild) {
                this.contentWrapper = (/** @type {?} */ (this.viewport.firstElementChild));
                this.contentWrapper.classList.add('ng-scroll-content');
            }
        };
        /**
         * @return {?}
         */
        NgScrollbar.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                _this.setViewport();
                // Initialize scroll streams
                _this.scrolled = new rxjs.Observable((/**
                 * @param {?} observer
                 * @return {?}
                 */
                function (observer) {
                    return rxjs.fromEvent(_this.viewport, 'scroll', { passive: true }).pipe(operators.takeUntil(_this.destroyed))
                        .subscribe(observer);
                }));
                _this.verticalScrolled = _this.getScrolledByDirection('vertical');
                _this.horizontalScrolled = _this.getScrolledByDirection('horizontal');
            }));
        };
        /**
         * @return {?}
         */
        NgScrollbar.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
        function () {
            this.updateState();
        };
        /**
         * @return {?}
         */
        NgScrollbar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroyed.next();
            this.destroyed.complete();
        };
        /**
         * Update local state and the internal scrollbar controls
         */
        /**
         * Update local state and the internal scrollbar controls
         * @return {?}
         */
        NgScrollbar.prototype.update = /**
         * Update local state and the internal scrollbar controls
         * @return {?}
         */
        function () {
            this.updated.next();
            this.changeDetectorRef.detectChanges();
        };
        /**
         * Smooth scroll functions
         */
        /**
         * Smooth scroll functions
         * @param {?} options
         * @return {?}
         */
        NgScrollbar.prototype.scrollTo = /**
         * Smooth scroll functions
         * @param {?} options
         * @return {?}
         */
        function (options) {
            return this.smoothScroll.scrollTo(this.viewport, options);
        };
        /**
         * Scroll to element by reference or selector
         */
        /**
         * Scroll to element by reference or selector
         * @param {?} target
         * @param {?=} options
         * @return {?}
         */
        NgScrollbar.prototype.scrollToElement = /**
         * Scroll to element by reference or selector
         * @param {?} target
         * @param {?=} options
         * @return {?}
         */
        function (target, options) {
            return this.smoothScroll.scrollToElement(this.viewport, target, options);
        };
        NgScrollbar.decorators = [
            { type: core.Component, args: [{
                        selector: 'ng-scrollbar',
                        exportAs: 'ngScrollbar',
                        template: "<div class=\"ng-scrollbar-wrapper\" [ngAttr]=\"state\">\r\n  <div class=\"ng-scroll-viewport-wrapper\"\r\n       resizeSensor\r\n       [sensorDebounce]=\"sensorDebounce\"\r\n       [sensorDisabled]=\"sensorDisabled\">\r\n    <div #viewport\r\n         [ngClass]=\"viewportClasses\"\r\n         [style]=\"nativeScrollbarSizeFactory.nativeScrollbarSize | async | cssVariable: 'native-scrollbar-size'\">\r\n      <div>\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <ng-container *ngIf=\"!disabled\">\r\n    <scrollbar-control *ngIf=\"state.verticalUsed\"\r\n                       track=\"vertical\"\r\n                       [attr.scrollable]=\"state.isVerticallyScrollable\"\r\n                       [attr.fit]=\"state.horizontalUsed\">\r\n    </scrollbar-control>\r\n    <scrollbar-control *ngIf=\"state.horizontalUsed\"\r\n                       track=\"horizontal\"\r\n                       [attr.scrollable]=\"state.isHorizontallyScrollable\"\r\n                       [attr.fit]=\"state.verticalUsed\">\r\n    </scrollbar-control>\r\n  </ng-container>\r\n</div>\r\n\r\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: { '[class.ng-scrollbar]': 'true' },
                        styles: ["::ng-deep .ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);display:block;position:relative;height:100%}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:.4s;transition-delay:0s}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-ms-scroll-chaining:contain contain;overscroll-behavior:contain contain;-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}"]
                    }] }
        ];
        /** @nocollapse */
        NgScrollbar.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: bidi.Directionality },
            { type: smoothScroll.SmoothScrollManager },
            { type: ScrollbarManager },
            { type: NativeScrollbarSizeFactory }
        ]; };
        NgScrollbar.propDecorators = {
            defaultViewPort: [{ type: core.ViewChild, args: ['viewport', { static: true },] }],
            customViewPort: [{ type: core.ContentChild, args: [ScrollViewport, { static: true },] }],
            viewClass: [{ type: core.Input }],
            trackClass: [{ type: core.Input }],
            thumbClass: [{ type: core.Input }],
            minThumbSize: [{ type: core.Input }],
            trackClickScrollDuration: [{ type: core.Input }],
            trackClickDisabled: [{ type: core.Input }],
            thumbDragDisabled: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            track: [{ type: core.Input }],
            visibility: [{ type: core.Input }],
            appearance: [{ type: core.Input }],
            position: [{ type: core.Input }],
            sensorDebounce: [{ type: core.Input }],
            sensorDisabled: [{ type: core.Input }],
            updated: [{ type: core.Output }]
        };
        return NgScrollbar;
    }());
    if (false) {
        /**
         * Default viewport reference
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.defaultViewPort;
        /**
         * Custom viewport reference
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.customViewPort;
        /**
         * A class forwarded to scrollable viewport element
         * @type {?}
         */
        NgScrollbar.prototype.viewClass;
        /**
         * A class forwarded to the scrollbar track element
         * @type {?}
         */
        NgScrollbar.prototype.trackClass;
        /**
         * A class forwarded to the scrollbar thumb element
         * @type {?}
         */
        NgScrollbar.prototype.thumbClass;
        /**
         * Minimum scrollbar thumb size
         * @type {?}
         */
        NgScrollbar.prototype.minThumbSize;
        /**
         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
         * @type {?}
         */
        NgScrollbar.prototype.trackClickScrollDuration;
        /**
         * A flag used to enable/disable the scrollbar track clicked event
         * @type {?}
         */
        NgScrollbar.prototype.trackClickDisabled;
        /**
         * A flag used to enable/disable the scrollbar thumb dragged event
         * @type {?}
         */
        NgScrollbar.prototype.thumbDragDisabled;
        /**
         * Disable custom scrollbar and switch back to native scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.disabled;
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `all` Use both vertical and horizontal scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         * @type {?}
         */
        NgScrollbar.prototype.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         * @type {?}
         */
        NgScrollbar.prototype.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         * @type {?}
         */
        NgScrollbar.prototype.position;
        /**
         * Debounce interval for detecting changes via ResizeObserver
         * @type {?}
         */
        NgScrollbar.prototype.sensorDebounce;
        /**
         * Whether ResizeObserver is disabled
         * @type {?}
         */
        NgScrollbar.prototype.sensorDisabled;
        /**
         * Steam that emits when scrollbar is updated
         * @type {?}
         */
        NgScrollbar.prototype.updated;
        /**
         * Viewport Element
         * @type {?}
         */
        NgScrollbar.prototype.viewport;
        /**
         * Content Wrapper element
         * @type {?}
         */
        NgScrollbar.prototype.contentWrapper;
        /**
         * stream that emits on scroll event
         * @type {?}
         */
        NgScrollbar.prototype.scrolled;
        /**
         * Steam that emits scroll event for vertical scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.verticalScrolled;
        /**
         * Steam that emits scroll event for horizontal scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.horizontalScrolled;
        /**
         * Default viewport classes
         * @type {?}
         */
        NgScrollbar.prototype.viewportClasses;
        /**
         * Set of attributes added on the scrollbar wrapper
         * @type {?}
         */
        NgScrollbar.prototype.state;
        /**
         * Stream that destroys components' observables
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.destroyed;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.el;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.zone;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.dir;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.smoothScroll;
        /** @type {?} */
        NgScrollbar.prototype.manager;
        /** @type {?} */
        NgScrollbar.prototype.nativeScrollbarSizeFactory;
    }
    /**
     * @record
     */
    function ScrollbarDragging() { }
    if (false) {
        /** @type {?|undefined} */
        ScrollbarDragging.prototype.verticalDragging;
        /** @type {?|undefined} */
        ScrollbarDragging.prototype.horizontalDragging;
    }
    /**
     * @record
     */
    function ScrollbarHovered() { }
    if (false) {
        /** @type {?|undefined} */
        ScrollbarHovered.prototype.verticalHovered;
        /** @type {?|undefined} */
        ScrollbarHovered.prototype.horizontalHovered;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */
    ScrollbarRef = /** @class */ (function () {
        function ScrollbarRef(scrollbarRef, document, trackRef, thumbRef, platform, destroyed) {
            var _this = this;
            this.scrollbarRef = scrollbarRef;
            this.document = document;
            this.destroyed = destroyed;
            this.viewElement = scrollbarRef.viewport;
            this.trackElement = trackRef.nativeElement;
            this.thumbElement = thumbRef.nativeElement;
            if (!(platform.IOS || platform.ANDROID)) {
                this.pointerEvents = new rxjs.Subject();
                this.hoveredState = new rxjs.Subject();
                this.draggingState = new rxjs.Subject();
                this.draggingState.pipe(operators.distinctUntilChanged(), operators.tap((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) { return _this.setDragging(state); })), operators.takeUntil(this.destroyed)).subscribe();
                /** @type {?} */
                var scrollbarClicked_1 = rxjs.fromEvent(this.viewElement, 'mousedown', { passive: true }).pipe(operators.switchMap((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    e.stopPropagation();
                    _this.document.onselectstart = (/**
                     * @return {?}
                     */
                    function () { return false; });
                    /** @type {?} */
                    var isThumbClick = isWithinBounds(e, _this.thumbElement.getBoundingClientRect());
                    if (isThumbClick && !coercion.coerceBooleanProperty(_this.scrollbarRef.thumbDragDisabled)) {
                        return _this.dragged(e);
                    }
                    else {
                        /** @type {?} */
                        var isTrackClick = isWithinBounds(e, _this.trackElement.getBoundingClientRect());
                        if (isTrackClick && !coercion.coerceBooleanProperty(_this.scrollbarRef.trackClickDisabled)) {
                            return _this.trackClicked(e);
                        }
                    }
                    return rxjs.EMPTY;
                })));
                // Activate/Deactivate scrollbar hover event
                /** @type {?} */
                var mouseLeave = rxjs.fromEvent(this.viewElement, 'mouseleave').pipe(operators.map((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    e.stopPropagation();
                    return false;
                })));
                rxjs.merge(this.pointerEvents, mouseLeave).pipe(operators.distinctUntilChanged()).pipe(operators.tap((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) { return _this.setHovered(state); })), operators.takeUntil(this.destroyed)).subscribe();
                // Activate/Deactivate scrollTo on scrollbar click event
                this.pointerEvents.pipe(operators.distinctUntilChanged(), operators.switchMap((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) { return state ? scrollbarClicked_1 : rxjs.EMPTY; })), operators.takeUntil(this.destroyed)).subscribe();
                this.hovered().pipe(operators.tap((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) { return _this.pointerEvents.next(state); })), operators.takeUntil(this.destroyed)).subscribe();
            }
            // Start updating thumb position when view scrolls
            this.scrolled().pipe(operators.tap((/**
             * @return {?}
             */
            function () { return _this.updateThumb(); })), operators.takeUntil(this.destroyed)).subscribe();
            // Update scrollbar when `NgScrollbar.update()` is called
            this.scrollbarRef.updated.pipe(operators.tap((/**
             * @return {?}
             */
            function () { return _this.updateThumb(); })), operators.takeUntil(this.destroyed)).subscribe();
            // Initialize scrollbar
            rxjs.asyncScheduler.schedule((/**
             * @return {?}
             */
            function () { return _this.updateThumb(); }), 100);
        }
        Object.defineProperty(ScrollbarRef.prototype, "scrollMax", {
            // The available scrollable size
            get: 
            // The available scrollable size
            /**
             * @protected
             * @return {?}
             */
            function () {
                return this.scrollSize - this.viewportSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollbarRef.prototype, "trackMax", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.trackSize - this.thumbSize;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Updates scrollbar's thumb position and size
         */
        /**
         * Updates scrollbar's thumb position and size
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.updateThumb = /**
         * Updates scrollbar's thumb position and size
         * @protected
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var trackMax = this.trackMax;
            /** @type {?} */
            var size = calculateThumbSize(this.trackSize, this.scrollSize, this.scrollbarRef.minThumbSize);
            /** @type {?} */
            var position = calculateThumbPosition(this.scrollOffset, this.scrollMax, trackMax);
            rxjs.animationFrameScheduler.schedule((/**
             * @return {?}
             */
            function () { return _this.applyThumbStyle(size, position, trackMax); }));
        };
        /**
         * @param {?} event
         * @return {?}
         */
        ScrollbarRef.prototype.dragged = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            /** @type {?} */
            var trackMax;
            /** @type {?} */
            var scrollMax;
            /** @type {?} */
            var dragStart = rxjs.of(event).pipe(operators.tap((/**
             * @return {?}
             */
            function () {
                // Capture scrollMax and trackMax once
                trackMax = _this.trackMax;
                scrollMax = _this.scrollMax;
                _this.draggingState.next(true);
            })));
            /** @type {?} */
            var dragging = rxjs.fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(operators.tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e.stopPropagation(); })));
            /** @type {?} */
            var dragEnd = rxjs.fromEvent(this.document, 'mouseup', { capture: true }).pipe(operators.tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                e.stopPropagation();
                _this.document.onselectstart = null;
                _this.draggingState.next(false);
            })));
            return dragStart.pipe(operators.pluck(this.pageProperty), operators.map((/**
             * @param {?} pageOffset
             * @return {?}
             */
            function (pageOffset) { return pageOffset - _this.dragStartOffset; })), operators.mergeMap((/**
             * @param {?} mouseDownOffset
             * @return {?}
             */
            function (mouseDownOffset) { return dragging.pipe(operators.pluck(_this.clientProperty), 
            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).
            operators.map((/**
             * @param {?} mouseOffset
             * @return {?}
             */
            function (mouseOffset) { return mouseOffset - _this.dragOffset; })), operators.map((/**
             * @param {?} offset
             * @return {?}
             */
            function (offset) { return scrollMax * (offset - mouseDownOffset) / trackMax; })), operators.map((/**
             * @param {?} position
             * @return {?}
             */
            function (position) { return _this.handleDragPosition(position, scrollMax); })), operators.tap((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return _this.scrollTo(value); })), operators.takeUntil(dragEnd)); })));
        };
        /**
         * Stream that emits when a scrollbar is hovered
         */
        /**
         * Stream that emits when a scrollbar is hovered
         * @private
         * @return {?}
         */
        ScrollbarRef.prototype.hovered = /**
         * Stream that emits when a scrollbar is hovered
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return rxjs.fromEvent(this.viewElement, 'mousemove', { passive: true }).pipe(operators.map((/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                e.stopPropagation();
                return isWithinBounds(e, _this.trackElement.getBoundingClientRect());
            })));
        };
        /**
         * Stream that emits when scrollbar track is clicked
         */
        /**
         * Stream that emits when scrollbar track is clicked
         * @protected
         * @param {?} e
         * @return {?}
         */
        ScrollbarRef.prototype.trackClicked = /**
         * Stream that emits when scrollbar track is clicked
         * @protected
         * @param {?} e
         * @return {?}
         */
        function (e) {
            var _this = this;
            return rxjs.of(e).pipe(operators.pluck(this.pageProperty), operators.map((/**
             * @param {?} pageOffset
             * @return {?}
             */
            function (pageOffset) { return pageOffset - _this.dragOffset; })), operators.map((/**
             * @param {?} clickOffset
             * @return {?}
             */
            function (clickOffset) {
                /** @type {?} */
                var offset = clickOffset - (_this.thumbSize / 2);
                /** @type {?} */
                var ratio = offset / _this.trackSize;
                return ratio * _this.scrollSize;
            })), operators.tap((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                return _this.scrollbarRef.scrollTo(__assign({}, _this.mapToScrollToOption(value), { duration: coercion.coerceNumberProperty(_this.scrollbarRef.trackClickScrollDuration) }));
            })), operators.tap((/**
             * @return {?}
             */
            function () { return _this.document.onselectstart = null; })));
        };
        return ScrollbarRef;
    }());
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.viewElement;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.trackElement;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.thumbElement;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.hoveredState;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.draggingState;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.pointerEvents;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.scrollbarRef;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarRef.prototype.destroyed;
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.scrollSize = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.viewportSize = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.trackSize = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.thumbSize = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.scrollOffset = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.dragStartOffset = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.dragOffset = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.pageProperty = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.clientProperty = function () { };
        /**
         * Stream that emits when view is scrolled
         * @abstract
         * @protected
         * @return {?}
         */
        ScrollbarRef.prototype.scrolled = function () { };
        /**
         * Return a scrollTo option parameter
         * @abstract
         * @protected
         * @param {?} value
         * @return {?}
         */
        ScrollbarRef.prototype.mapToScrollToOption = function (value) { };
        /**
         * Updates scrollbar's thumb size and position
         * @abstract
         * @protected
         * @param {?} size
         * @param {?} position
         * @param {?=} trackMax
         * @return {?}
         */
        ScrollbarRef.prototype.applyThumbStyle = function (size, position, trackMax) { };
        /**
         * On drag function
         * @abstract
         * @protected
         * @param {?} position
         * @param {?} scrollMax
         * @return {?}
         */
        ScrollbarRef.prototype.handleDragPosition = function (position, scrollMax) { };
        /**
         * @abstract
         * @protected
         * @param {?} point
         * @return {?}
         */
        ScrollbarRef.prototype.scrollTo = function (point) { };
        /**
         * @abstract
         * @protected
         * @param {?} value
         * @return {?}
         */
        ScrollbarRef.prototype.setDragging = function (value) { };
        /**
         * @abstract
         * @protected
         * @param {?} value
         * @return {?}
         */
        ScrollbarRef.prototype.setHovered = function (value) { };
    }
    /**
     * Calculate Scrollbar thumb size
     * @param {?} trackSize Scrollbar track size
     * @param {?} contentSize Content size or Viewport scroll size
     * @param {?} minThumbSize Minimum scrollbar thumb size
     * @return {?}
     */
    function calculateThumbSize(trackSize, contentSize, minThumbSize) {
        /** @type {?} */
        var scrollbarRatio = trackSize / contentSize;
        /** @type {?} */
        var thumbSize = scrollbarRatio * trackSize;
        return Math.max(~~thumbSize, minThumbSize);
    }
    /**
     * Calculate scrollbar thumb position
     * @param {?} scrollPosition The scroll position of the viewport
     * @param {?} scrollMax The max size available to scroll the viewport
     * @param {?} trackMax The max size available to move scrollbar thumb
     * @return {?}
     */
    function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
        return scrollPosition * trackMax / scrollMax;
    }
    /**
     * Check if pointer is within scrollbar bounds
     * @param {?} e Pointer event
     * @param {?} rect Scrollbar Client Rect
     * @return {?}
     */
    function isWithinBounds(e, rect) {
        return (e.clientX >= rect.left &&
            e.clientX <= rect.left + rect.width &&
            e.clientY >= rect.top &&
            e.clientY <= rect.top + rect.height);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HorizontalScrollbarRef = /** @class */ (function (_super) {
        __extends(HorizontalScrollbarRef, _super);
        function HorizontalScrollbarRef(scrollbarRef, document, trackRef, thumbRef, platform, destroyed, dir) {
            var _this = _super.call(this, scrollbarRef, document, trackRef, thumbRef, platform, destroyed) || this;
            _this.scrollbarRef = scrollbarRef;
            _this.document = document;
            _this.platform = platform;
            _this.destroyed = destroyed;
            _this.dir = dir;
            return _this;
        }
        Object.defineProperty(HorizontalScrollbarRef.prototype, "scrollSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.viewElement.scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "viewportSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.viewElement.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "trackSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.trackElement.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "thumbSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.thumbElement.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "scrollOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.viewElement.scrollLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "dragOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.trackElement.getBoundingClientRect().left;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "dragStartOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.thumbElement.getBoundingClientRect().left;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "pageProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'pageX';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HorizontalScrollbarRef.prototype, "clientProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'clientX';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @param {?} position
         * @param {?} trackMax
         * @return {?}
         */
        HorizontalScrollbarRef.prototype._handleThumbPosition = /**
         * @private
         * @param {?} position
         * @param {?} trackMax
         * @return {?}
         */
        function (position, trackMax) {
            if (this.dir.value === 'rtl') {
                if (this.scrollbarRef.manager.rtlScrollAxisType === platform.RtlScrollAxisType.INVERTED) {
                    return -position;
                }
                if (this.scrollbarRef.manager.rtlScrollAxisType === platform.RtlScrollAxisType.NORMAL) {
                    return position - trackMax;
                }
                // Keeping this as a memo
                // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                //   return position;
                // }
            }
            return position;
        };
        /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.handleDragPosition = /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        function (position) {
            if (this.dir.value === 'rtl') {
                if (this.scrollbarRef.manager.rtlScrollAxisType === platform.RtlScrollAxisType.NEGATED) {
                    return position - this.scrollMax;
                }
                if (this.scrollbarRef.manager.rtlScrollAxisType === platform.RtlScrollAxisType.INVERTED) {
                    return this.scrollMax - position;
                }
                // Keeping this as a memo
                // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
                //   return position;
                // }
            }
            return position;
        };
        /**
         * @protected
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.scrolled = /**
         * @protected
         * @return {?}
         */
        function () {
            return this.scrollbarRef.horizontalScrolled;
        };
        /**
         * @protected
         * @param {?} size
         * @param {?} position
         * @param {?=} trackMax
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.applyThumbStyle = /**
         * @protected
         * @param {?} size
         * @param {?} position
         * @param {?=} trackMax
         * @return {?}
         */
        function (size, position, trackMax) {
            this.thumbElement.style.width = size + "px";
            this.thumbElement.style.transform = "translate3d(" + this._handleThumbPosition(position, trackMax) + "px, 0, 0)";
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.mapToScrollToOption = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return { left: value };
        };
        /**
         * @protected
         * @param {?} point
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.scrollTo = /**
         * @protected
         * @param {?} point
         * @return {?}
         */
        function (point) {
            this.viewElement.scrollLeft = point;
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.setHovered = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.scrollbarRef.setHovered({ horizontalHovered: value });
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        HorizontalScrollbarRef.prototype.setDragging = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.scrollbarRef.setDragging({ horizontalDragging: value });
        };
        return HorizontalScrollbarRef;
    }(ScrollbarRef));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        HorizontalScrollbarRef.prototype.scrollbarRef;
        /**
         * @type {?}
         * @protected
         */
        HorizontalScrollbarRef.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        HorizontalScrollbarRef.prototype.platform;
        /**
         * @type {?}
         * @protected
         */
        HorizontalScrollbarRef.prototype.destroyed;
        /**
         * @type {?}
         * @protected
         */
        HorizontalScrollbarRef.prototype.dir;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var VerticalScrollbarRef = /** @class */ (function (_super) {
        __extends(VerticalScrollbarRef, _super);
        function VerticalScrollbarRef(scrollbarRef, document, trackRef, thumbRef, platform, destroyed) {
            var _this = _super.call(this, scrollbarRef, document, trackRef, thumbRef, platform, destroyed) || this;
            _this.scrollbarRef = scrollbarRef;
            _this.document = document;
            _this.destroyed = destroyed;
            return _this;
        }
        Object.defineProperty(VerticalScrollbarRef.prototype, "scrollSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.viewElement.scrollHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "viewportSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.viewElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "trackSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.trackElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "thumbSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.thumbElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "scrollOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.viewElement.scrollTop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "dragOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.trackElement.getBoundingClientRect().top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "dragStartOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.thumbElement.getBoundingClientRect().top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "pageProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'pageY';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollbarRef.prototype, "clientProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'clientY';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        VerticalScrollbarRef.prototype.scrolled = /**
         * @protected
         * @return {?}
         */
        function () {
            return this.scrollbarRef.verticalScrolled;
        };
        /**
         * @protected
         * @param {?} size
         * @param {?} position
         * @return {?}
         */
        VerticalScrollbarRef.prototype.applyThumbStyle = /**
         * @protected
         * @param {?} size
         * @param {?} position
         * @return {?}
         */
        function (size, position) {
            this.thumbElement.style.height = size + "px";
            this.thumbElement.style.transform = "translate3d(0 ," + position + "px, 0)";
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        VerticalScrollbarRef.prototype.mapToScrollToOption = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return { top: value };
        };
        /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        VerticalScrollbarRef.prototype.handleDragPosition = /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        function (position) {
            return position;
        };
        /**
         * @protected
         * @param {?} point
         * @return {?}
         */
        VerticalScrollbarRef.prototype.scrollTo = /**
         * @protected
         * @param {?} point
         * @return {?}
         */
        function (point) {
            this.viewElement.scrollTop = point;
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        VerticalScrollbarRef.prototype.setHovered = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.scrollbarRef.setHovered({ verticalHovered: value });
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        VerticalScrollbarRef.prototype.setDragging = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.scrollbarRef.setDragging({ verticalDragging: value });
        };
        return VerticalScrollbarRef;
    }(ScrollbarRef));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        VerticalScrollbarRef.prototype.scrollbarRef;
        /**
         * @type {?}
         * @protected
         */
        VerticalScrollbarRef.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        VerticalScrollbarRef.prototype.destroyed;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ScrollbarControl = /** @class */ (function () {
        function ScrollbarControl(parent, platform, dir, zone, document) {
            this.parent = parent;
            this.platform = platform;
            this.dir = dir;
            this.zone = zone;
            this.document = document;
            // Stream that emits to unsubscribe from all streams
            this.destroyed = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        ScrollbarControl.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                // Avoid SSR Error
                if (_this.platform.isBrowser) {
                    _this.scrollbarRef = _this.track === 'vertical'
                        ? new VerticalScrollbarRef(_this.parent, _this.document, _this.trackRef, _this.thumbRef, _this.platform, _this.destroyed)
                        : new HorizontalScrollbarRef(_this.parent, _this.document, _this.trackRef, _this.thumbRef, _this.platform, _this.destroyed, _this.dir);
                }
            }));
        };
        /**
         * @return {?}
         */
        ScrollbarControl.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroyed.next();
            this.destroyed.complete();
        };
        ScrollbarControl.decorators = [
            { type: core.Component, args: [{
                        selector: 'scrollbar-control',
                        host: {
                            '[class.scrollbar-control]': 'true'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "\n    <div #track class=\"ng-scrollbar-track {{parent.trackClass}}\">\n      <div #thumb class=\"ng-scrollbar-thumb {{parent.thumbClass}}\"></div>\n    </div>\n  ",
                        styles: ["::ng-deep .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-track,::ng-deep .scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:height 150ms ease-out,width 150ms ease-out}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:height 150ms ease-out,width 150ms ease-out;cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:height 150ms ease-out,width 150ms ease-out}", "::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>.scrollbar-control[track=horizontal],::ng-deep .ng-scrollbar-wrapper[position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=horizontal]{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][position=invertAll]>.scrollbar-control[track=horizontal],::ng-deep .ng-scrollbar-wrapper[disabled=false][position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}", "::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=vertical]{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr]>.scrollbar-control[track=vertical]{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertAll]>.scrollbar-control[track=vertical],::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertY]>.scrollbar-control[track=vertical]{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl]>.scrollbar-control[track=vertical]{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertAll]>.scrollbar-control[track=vertical],::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertY]>.scrollbar-control[track=vertical]{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all]>.scrollbar-control[track=vertical][fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][position=invertAll]>.scrollbar-control[track=vertical][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][position=invertX]>.scrollbar-control[track=vertical][fit=true]{top:var(--scrollbar-total-size);bottom:0}"]
                    }] }
        ];
        /** @nocollapse */
        ScrollbarControl.ctorParameters = function () { return [
            { type: NgScrollbar },
            { type: platform.Platform },
            { type: bidi.Directionality },
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        ScrollbarControl.propDecorators = {
            track: [{ type: core.Input }],
            trackRef: [{ type: core.ViewChild, args: ['track', { static: true },] }],
            thumbRef: [{ type: core.ViewChild, args: ['thumb', { static: true },] }]
        };
        return ScrollbarControl;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ScrollbarControl.prototype.scrollbarRef;
        /**
         * @type {?}
         * @private
         */
        ScrollbarControl.prototype.track;
        /** @type {?} */
        ScrollbarControl.prototype.trackRef;
        /** @type {?} */
        ScrollbarControl.prototype.thumbRef;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarControl.prototype.destroyed;
        /** @type {?} */
        ScrollbarControl.prototype.parent;
        /**
         * @type {?}
         * @private
         */
        ScrollbarControl.prototype.platform;
        /**
         * @type {?}
         * @private
         */
        ScrollbarControl.prototype.dir;
        /**
         * @type {?}
         * @private
         */
        ScrollbarControl.prototype.zone;
        /**
         * @type {?}
         * @private
         */
        ScrollbarControl.prototype.document;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CssVariable = /** @class */ (function () {
        function CssVariable(sanitizer) {
            this.sanitizer = sanitizer;
        }
        /**
         * @param {?} size
         * @param {?} variableName
         * @return {?}
         */
        CssVariable.prototype.transform = /**
         * @param {?} size
         * @param {?} variableName
         * @return {?}
         */
        function (size, variableName) {
            return this.sanitizer.bypassSecurityTrustStyle("--" + variableName + ": -" + size + "px");
        };
        CssVariable.decorators = [
            { type: core.Pipe, args: [{
                        name: 'cssVariable'
                    },] }
        ];
        /** @nocollapse */
        CssVariable.ctorParameters = function () { return [
            { type: platformBrowser.DomSanitizer }
        ]; };
        return CssVariable;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        CssVariable.prototype.sanitizer;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgAttr = /** @class */ (function () {
        function NgAttr(el) {
            this.el = el;
        }
        Object.defineProperty(NgAttr.prototype, "ngAttr", {
            set: /**
             * @param {?} attrs
             * @return {?}
             */
            function (attrs) {
                var e_1, _a;
                try {
                    for (var _b = __values(Object.entries(attrs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                        ((/** @type {?} */ (this.el.nativeElement))).setAttribute(key, value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            },
            enumerable: true,
            configurable: true
        });
        NgAttr.decorators = [
            { type: core.Directive, args: [{ selector: '[ngAttr]' },] }
        ];
        /** @nocollapse */
        NgAttr.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        NgAttr.propDecorators = {
            ngAttr: [{ type: core.Input }]
        };
        return NgAttr;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NgAttr.prototype.el;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Factory that initialize the ResizeObserver if available in the browser
     * Otherwise, it lazy-loads the ResizeObserver polyfill
     */
    var ResizeObserverFactory = /** @class */ (function () {
        function ResizeObserverFactory(document, platform) {
            this.resizeObserverSource = new rxjs.BehaviorSubject(null);
            this.resizeObserverLoader = this.resizeObserverSource.asObservable();
            if (platform.isBrowser) {
                /** @type {?} */
                var resizeObserverApi = document.defaultView.ResizeObserver
                    ? rxjs.of(document.defaultView.ResizeObserver)
                    : rxjs.from(import('@juggle/resize-observer')).pipe(operators.map((/**
                     * @param {?} module
                     * @return {?}
                     */
                    function (module) { return module.ResizeObserver; })), operators.catchError((/**
                     * @param {?} e
                     * @return {?}
                     */
                    function (e) {
                        console.log('Unable to load ResizeObserver polyfill', e);
                        return rxjs.EMPTY;
                    })));
                this.resizeObserverSource.next(resizeObserverApi);
            }
        }
        ResizeObserverFactory.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        ResizeObserverFactory.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: platform.Platform }
        ]; };
        /** @nocollapse */ ResizeObserverFactory.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function ResizeObserverFactory_Factory() { return new ResizeObserverFactory(core.ɵɵinject(common.DOCUMENT), core.ɵɵinject(platform.Platform)); }, token: ResizeObserverFactory, providedIn: "root" });
        return ResizeObserverFactory;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ResizeObserverFactory.prototype.resizeObserverSource;
        /** @type {?} */
        ResizeObserverFactory.prototype.resizeObserverLoader;
    }
    var ResizeSensor = /** @class */ (function () {
        function ResizeSensor(zone, platform, resizeObserverFactory, scrollbar) {
            this.zone = zone;
            this.platform = platform;
            this.resizeObserverFactory = resizeObserverFactory;
            this.scrollbar = scrollbar;
            this._disabled = false;
            this._subscription = null;
            if (!scrollbar) {
                throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');
            }
        }
        Object.defineProperty(ResizeSensor.prototype, "debounce", {
            /** Debounce interval for emitting the changes. */
            get: /**
             * Debounce interval for emitting the changes.
             * @return {?}
             */
            function () {
                return this._debounce;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._debounce = coercion.coerceNumberProperty(value);
                this._subscribe();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizeSensor.prototype, "disabled", {
            /** Whether ResizeObserver is disabled. */
            get: /**
             * Whether ResizeObserver is disabled.
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._disabled ? this._unsubscribe() : this._subscribe();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ResizeSensor.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (!this._subscription && !this._disabled) {
                this._subscribe();
            }
        };
        /**
         * @return {?}
         */
        ResizeSensor.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._unsubscribe();
        };
        /**
         * @private
         * @param {?} ResizeObserver
         * @return {?}
         */
        ResizeSensor.prototype._createObserver = /**
         * @private
         * @param {?} ResizeObserver
         * @return {?}
         */
        function (ResizeObserver) {
            var _this = this;
            return new rxjs.Observable((/**
             * @param {?} observer
             * @return {?}
             */
            function (observer) {
                _this._resizeObserver = new ResizeObserver((/**
                 * @return {?}
                 */
                function () { return observer.next(); }));
                _this._resizeObserver.observe(_this.scrollbar.viewport);
                if (_this.scrollbar.contentWrapper) {
                    _this._resizeObserver.observe(_this.scrollbar.contentWrapper);
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        ResizeSensor.prototype._subscribe = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._unsubscribe();
            if (this.platform.isBrowser) {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    _this._subscription = _this.resizeObserverFactory.resizeObserverLoader.pipe(operators.switchMap((/**
                     * @param {?} moduleObservable
                     * @return {?}
                     */
                    function (moduleObservable) { return moduleObservable; })), operators.switchMap((/**
                     * @param {?} ResizeObserver
                     * @return {?}
                     */
                    function (ResizeObserver) {
                        if (ResizeObserver) {
                            /** @type {?} */
                            var stream = _this._createObserver(ResizeObserver);
                            return _this.debounce ? stream.pipe(operators.debounceTime(_this._debounce)) : stream;
                        }
                        else {
                            return rxjs.EMPTY;
                        }
                    }))).subscribe((/**
                     * @return {?}
                     */
                    function () { return _this.scrollbar.update(); }));
                }));
            }
        };
        /**
         * @private
         * @return {?}
         */
        ResizeSensor.prototype._unsubscribe = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            if (this._subscription) {
                this._subscription.unsubscribe();
            }
        };
        ResizeSensor.decorators = [
            { type: core.Directive, args: [{ selector: '[resizeSensor]' },] }
        ];
        /** @nocollapse */
        ResizeSensor.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: platform.Platform },
            { type: ResizeObserverFactory },
            { type: NgScrollbar }
        ]; };
        ResizeSensor.propDecorators = {
            debounce: [{ type: core.Input, args: ['sensorDebounce',] }],
            disabled: [{ type: core.Input, args: ['sensorDisabled',] }]
        };
        return ResizeSensor;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._debounce;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._subscription;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._resizeObserver;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.zone;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.platform;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.resizeObserverFactory;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.scrollbar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgScrollbarModule = /** @class */ (function () {
        function NgScrollbarModule() {
        }
        NgScrollbarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            bidi.BidiModule,
                            portal.PortalModule,
                            platform.PlatformModule,
                            smoothScroll.SmoothScrollModule
                        ],
                        declarations: [
                            NgScrollbar,
                            ScrollbarControl,
                            ScrollViewport,
                            CssVariable,
                            NgAttr,
                            ResizeSensor
                        ],
                        exports: [
                            NgScrollbar,
                            ScrollViewport
                        ]
                    },] }
        ];
        return NgScrollbarModule;
    }());

    exports.NG_SCROLLBAR_OPTIONS = NG_SCROLLBAR_OPTIONS;
    exports.NgScrollbar = NgScrollbar;
    exports.NgScrollbarModule = NgScrollbarModule;
    exports.ScrollViewport = ScrollViewport;
    exports.ScrollbarManager = ScrollbarManager;
    exports.ɵa = NativeScrollbarSizeFactory;
    exports.ɵb = ScrollbarControl;
    exports.ɵc = CssVariable;
    exports.ɵd = NgAttr;
    exports.ɵe = ResizeObserverFactory;
    exports.ɵf = ResizeSensor;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-scrollbar.umd.js.map
