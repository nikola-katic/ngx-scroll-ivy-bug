import { __assign } from 'tslib';
import { InjectionToken, Injectable, NgZone, Inject, PLATFORM_ID, Optional, ɵɵdefineInjectable, ɵɵinject, Directive, ElementRef, NgModule } from '@angular/core';
import { isPlatformBrowser, DOCUMENT } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { Directionality } from '@angular/cdk/bidi';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';
import { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');
/**
 * @record
 */
function SmoothScrollOptions() { }
if (false) {
    /** @type {?|undefined} */
    SmoothScrollOptions.prototype.duration;
    /** @type {?|undefined} */
    SmoothScrollOptions.prototype.easing;
}
/**
 * @record
 */
function SmoothScrollStep() { }
if (false) {
    /** @type {?} */
    SmoothScrollStep.prototype.scrollable;
    /** @type {?} */
    SmoothScrollStep.prototype.startTime;
    /** @type {?} */
    SmoothScrollStep.prototype.startX;
    /** @type {?} */
    SmoothScrollStep.prototype.startY;
    /** @type {?} */
    SmoothScrollStep.prototype.x;
    /** @type {?} */
    SmoothScrollStep.prototype.y;
    /** @type {?} */
    SmoothScrollStep.prototype.duration;
    /** @type {?} */
    SmoothScrollStep.prototype.easing;
    /** @type {?|undefined} */
    SmoothScrollStep.prototype.currentX;
    /** @type {?|undefined} */
    SmoothScrollStep.prototype.currentY;
}
/**
 * @record
 */
function BezierEasingOptions() { }
if (false) {
    /** @type {?} */
    BezierEasingOptions.prototype.x1;
    /** @type {?} */
    BezierEasingOptions.prototype.y1;
    /** @type {?} */
    BezierEasingOptions.prototype.x2;
    /** @type {?} */
    BezierEasingOptions.prototype.y2;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
var SmoothScrollManager = /** @class */ (function () {
    function SmoothScrollManager(_zone, _dir, _document, _platform, customDefaultOptions) {
        this._zone = _zone;
        this._dir = _dir;
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = __assign({ duration: 468, easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            } }, customDefaultOptions);
    }
    Object.defineProperty(SmoothScrollManager.prototype, "_w", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._document.defaultView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmoothScrollManager.prototype, "_now", {
        /**
         * Timing method
         */
        get: /**
         * Timing method
         * @private
         * @return {?}
         */
        function () {
            return this._w.performance && this._w.performance.now
                ? this._w.performance.now.bind(this._w.performance)
                : Date.now;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * changes scroll position inside an element
     */
    /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    SmoothScrollManager.prototype._scrollElement = /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    };
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    SmoothScrollManager.prototype._getElement = /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    function (el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    };
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    SmoothScrollManager.prototype._initSmoothScroll = /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    };
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    SmoothScrollManager.prototype._isFinished = /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    function (context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    };
    /**
     * Terminates an ongoing smooth scroll
     */
    /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    SmoothScrollManager.prototype._interrupted = /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    function (el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    };
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    SmoothScrollManager.prototype._destroy = /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    function (el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    };
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    SmoothScrollManager.prototype._step = /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var elapsed = (_this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            /** @type {?} */
            var value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            _this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule((/**
             * @return {?}
             */
            function () { return observer.next(context); }));
        }));
    };
    /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    SmoothScrollManager.prototype._applyScrollToOptions = /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    function (el, options) {
        var _this = this;
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        /** @type {?} */
        var destroyed = this._initSmoothScroll(el);
        /** @type {?} */
        var easingOptions = options.easing || this._defaultOptions.easing;
        /** @type {?} */
        var context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration || this._defaultOptions.duration,
            easing: BezierEasing(easingOptions.x1, easingOptions.y1, easingOptions.x2, easingOptions.y2)
        };
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        function (resolve) {
            // Scroll each step recursively
            of(null).pipe(expand((/**
             * @return {?}
             */
            function () { return _this._step(context).pipe(takeWhile((/**
             * @param {?} currContext
             * @return {?}
             */
            function (currContext) { return _this._isFinished(currContext, destroyed, resolve); }))); })), takeUntil(_this._interrupted(el, destroyed)), finalize((/**
             * @return {?}
             */
            function () { return _this._destroy(el, destroyed); }))).subscribe();
        }));
    };
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param options specified the offsets to scroll to.
     */
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} options specified the offsets to scroll to.
     * @return {?}
     */
    SmoothScrollManager.prototype.scrollTo = /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} options specified the offsets to scroll to.
     * @return {?}
     */
    function (scrollable, options) {
        if (isPlatformBrowser(this._platform)) {
            /** @type {?} */
            var el = this._getElement(scrollable);
            /** @type {?} */
            var isRtl = getComputedStyle(el).direction === 'rtl';
            /** @type {?} */
            var rtlScrollAxisType = getRtlScrollAxisType();
            // Rewrite start & end offsets as right or left offsets.
            options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;
            options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                ((/** @type {?} */ (options))).top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
                if (options.left != null) {
                    ((/** @type {?} */ (options))).right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    ((/** @type {?} */ (options))).left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
    };
    /**
     * Scroll to element by reference or selector
     */
    /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    SmoothScrollManager.prototype.scrollToElement = /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    function (scrollable, target, options) {
        /** @type {?} */
        var scrollableEl = this._getElement(scrollable);
        /** @type {?} */
        var targetEl = this._getElement(target, scrollableEl);
        /** @type {?} */
        var duration = options.duration;
        /** @type {?} */
        var easing = options.easing;
        return targetEl ? this.scrollTo(scrollableEl, {
            left: targetEl.offsetLeft + (options.left || 0),
            top: targetEl.offsetTop + (options.top || 0),
            duration: duration,
            easing: easing
        }) : new Promise(null);
    };
    SmoothScrollManager.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SmoothScrollManager.ctorParameters = function () { return [
        { type: NgZone },
        { type: Directionality },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
    ]; };
    /** @nocollapse */ SmoothScrollManager.ngInjectableDef = ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(ɵɵinject(NgZone), ɵɵinject(Directionality), ɵɵinject(DOCUMENT), ɵɵinject(PLATFORM_ID), ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
    return SmoothScrollManager;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._defaultOptions;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._onGoingScrolls;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._zone;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._document;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._platform;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SmoothScroll = /** @class */ (function () {
    function SmoothScroll(element, smoothScroll) {
        this.element = element;
        this.smoothScroll = smoothScroll;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    SmoothScroll.prototype.scrollTo = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.smoothScroll.scrollTo(this.element, options);
    };
    /**
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    SmoothScroll.prototype.scrollToElement = /**
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    function (target, options) {
        return this.smoothScroll.scrollToElement(this.element, target, options);
    };
    SmoothScroll.decorators = [
        { type: Directive, args: [{
                    selector: '[smoothScroll], [smooth-scroll]',
                    exportAs: 'smoothScroll'
                },] }
    ];
    /** @nocollapse */
    SmoothScroll.ctorParameters = function () { return [
        { type: ElementRef },
        { type: SmoothScrollManager }
    ]; };
    return SmoothScroll;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmoothScroll.prototype.element;
    /**
     * @type {?}
     * @private
     */
    SmoothScroll.prototype.smoothScroll;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SmoothScrollModule = /** @class */ (function () {
    function SmoothScrollModule() {
    }
    SmoothScrollModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [SmoothScroll],
                    exports: [SmoothScroll]
                },] }
    ];
    return SmoothScrollModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };
//# sourceMappingURL=ngx-scrollbar-smooth-scroll.js.map
