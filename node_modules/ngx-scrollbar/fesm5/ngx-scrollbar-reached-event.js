import { Input, Optional, NgZone, Directive, Output, NgModule } from '@angular/core';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { NgScrollbar, NgScrollbarModule } from 'ngx-scrollbar';
import { __extends } from 'tslib';
import { RtlScrollAxisType } from '@angular/cdk/platform';
import { Subject, Subscription, Observable } from 'rxjs';
import { tap, map, distinctUntilChanged, filter } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
var 
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
ReachedFunctions = /** @class */ (function () {
    function ReachedFunctions() {
    }
    /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    ReachedFunctions.reachedTop = /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    };
    /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    ReachedFunctions.reachedBottom = /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    };
    /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    ReachedFunctions.reachedStart = /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    function (offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    };
    /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    ReachedFunctions.reachedEnd = /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    function (offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    };
    /**
     * @param {?} currPosition
     * @param {?} targetPosition
     * @param {?} offset
     * @return {?}
     */
    ReachedFunctions.reached = /**
     * @param {?} currPosition
     * @param {?} targetPosition
     * @param {?} offset
     * @return {?}
     */
    function (currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    };
    return ReachedFunctions;
}());
/**
 * @abstract
 */
var ScrollReached = /** @class */ (function () {
    function ScrollReached(scrollbar, zone) {
        var _this = this;
        this.scrollbar = scrollbar;
        this.zone = zone;
        /**
         * offset: Reached offset value in px
         */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /**
         * subscription: Scrolled event subscription, used to unsubscribe from the event on destroy
         */
        this.subscription = Subscription.EMPTY;
        /**
         * A stream used to assign the reached output
         */
        this.reachedEvent = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            return _this.scrollReached().subscribe((/**
             * @param {?} _
             * @return {?}
             */
            function (_) {
                return Promise.resolve().then((/**
                 * @return {?}
                 */
                function () { return _this.zone.run((/**
                 * @return {?}
                 */
                function () { return observer.next(_); })); }));
            }));
        }));
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    /**
     * @return {?}
     */
    ScrollReached.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @protected
     * @return {?}
     */
    ScrollReached.prototype.scrollReached = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        // current event
        /** @type {?} */
        var currEvent;
        return this.scrollEvent.pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return currEvent = e; })), 
        // Check if it scroll has reached
        map((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.reached(_this.offset, e); })), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((/**
         * @param {?} reached
         * @return {?}
         */
        function (reached) { return reached; })), 
        // Return scroll event
        map((/**
         * @return {?}
         */
        function () { return currEvent; })));
    };
    ScrollReached.propDecorators = {
        offset: [{ type: Input, args: ['reachedOffset',] }]
    };
    return ScrollReached;
}());
if (false) {
    /**
     * offset: Reached offset value in px
     * @type {?}
     */
    ScrollReached.prototype.offset;
    /**
     * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
     *
     * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.scrollEvent;
    /**
     * subscription: Scrolled event subscription, used to unsubscribe from the event on destroy
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.subscription;
    /**
     * A stream used to assign the reached output
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.reachedEvent;
    /**
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.zone;
    /**
     * @abstract
     * @protected
     * @param {?} offset
     * @param {?=} e
     * @return {?}
     */
    ScrollReached.prototype.reached = function (offset, e) { };
}
/**
 * @abstract
 */
var VerticalScrollReached = /** @class */ (function (_super) {
    __extends(VerticalScrollReached, _super);
    function VerticalScrollReached(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        return _this;
    }
    /**
     * @return {?}
     */
    VerticalScrollReached.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    };
    /** @nocollapse */
    VerticalScrollReached.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    return VerticalScrollReached;
}(ScrollReached));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollReached.prototype.zone;
}
/**
 * @abstract
 */
var HorizontalScrollReached = /** @class */ (function (_super) {
    __extends(HorizontalScrollReached, _super);
    function HorizontalScrollReached(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        return _this;
    }
    /**
     * @return {?}
     */
    HorizontalScrollReached.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    };
    /** @nocollapse */
    HorizontalScrollReached.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    return HorizontalScrollReached;
}(ScrollReached));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollReached.prototype.zone;
}
var NgScrollbarReachedTop = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedTop, _super);
    function NgScrollbarReachedTop(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        /**
         * Stream that emits when scroll has reached the top
         */
        _this.reachedTop = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedTop.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the top (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedTop.prototype.reached = /**
     * Check if scroll has reached the top (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    };
    NgScrollbarReachedTop.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedTop], [reached-top]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedTop.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    NgScrollbarReachedTop.propDecorators = {
        reachedTop: [{ type: Output }]
    };
    return NgScrollbarReachedTop;
}(VerticalScrollReached));
if (false) {
    /**
     * Stream that emits when scroll has reached the top
     * @type {?}
     */
    NgScrollbarReachedTop.prototype.reachedTop;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedTop.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedTop.prototype.zone;
}
var NgScrollbarReachedBottom = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedBottom, _super);
    function NgScrollbarReachedBottom(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        /**
         * Stream that emits when scroll has reached the bottom
         */
        _this.reachedBottom = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedBottom.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the bottom (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedBottom.prototype.reached = /**
     * Check if scroll has reached the bottom (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    };
    NgScrollbarReachedBottom.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedBottom], [reached-bottom]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedBottom.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    NgScrollbarReachedBottom.propDecorators = {
        reachedBottom: [{ type: Output }]
    };
    return NgScrollbarReachedBottom;
}(VerticalScrollReached));
if (false) {
    /**
     * Stream that emits when scroll has reached the bottom
     * @type {?}
     */
    NgScrollbarReachedBottom.prototype.reachedBottom;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedBottom.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedBottom.prototype.zone;
}
var NgScrollbarReachedStart = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedStart, _super);
    function NgScrollbarReachedStart(scrollbar, zone, dir) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        _this.dir = dir;
        /**
         * Stream that emits when scroll has reached the start
         */
        _this.reachedStart = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedStart.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the start (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedStart.prototype.reached = /**
     * Check if scroll has reached the start (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    };
    NgScrollbarReachedStart.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedStart], [reached-start]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedStart.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone },
        { type: Directionality }
    ]; };
    NgScrollbarReachedStart.propDecorators = {
        reachedStart: [{ type: Output }]
    };
    return NgScrollbarReachedStart;
}(HorizontalScrollReached));
if (false) {
    /**
     * Stream that emits when scroll has reached the start
     * @type {?}
     */
    NgScrollbarReachedStart.prototype.reachedStart;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedStart.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedStart.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbarReachedStart.prototype.dir;
}
var NgScrollbarReachedEnd = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedEnd, _super);
    function NgScrollbarReachedEnd(scrollbar, zone, dir) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        _this.dir = dir;
        /**
         * Stream that emits when scroll has reached the end
         */
        _this.reachedEnd = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedEnd.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the end (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedEnd.prototype.reached = /**
     * Check if scroll has reached the end (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    };
    NgScrollbarReachedEnd.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedEnd], [reached-end]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedEnd.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone },
        { type: Directionality }
    ]; };
    NgScrollbarReachedEnd.propDecorators = {
        reachedEnd: [{ type: Output }]
    };
    return NgScrollbarReachedEnd;
}(HorizontalScrollReached));
if (false) {
    /**
     * Stream that emits when scroll has reached the end
     * @type {?}
     */
    NgScrollbarReachedEnd.prototype.reachedEnd;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedEnd.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedEnd.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbarReachedEnd.prototype.dir;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgScrollbarReachedModule = /** @class */ (function () {
    function NgScrollbarReachedModule() {
    }
    NgScrollbarReachedModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        NgScrollbarModule,
                        BidiModule
                    ],
                    declarations: [
                        NgScrollbarReachedTop,
                        NgScrollbarReachedBottom,
                        NgScrollbarReachedStart,
                        NgScrollbarReachedEnd
                    ],
                    exports: [
                        NgScrollbarReachedTop,
                        NgScrollbarReachedBottom,
                        NgScrollbarReachedStart,
                        NgScrollbarReachedEnd
                    ]
                },] }
    ];
    return NgScrollbarReachedModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgScrollbarReachedBottom, NgScrollbarReachedEnd, NgScrollbarReachedModule, NgScrollbarReachedStart, NgScrollbarReachedTop };
//# sourceMappingURL=ngx-scrollbar-reached-event.js.map
