/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, PLATFORM_ID, Optional, NgZone } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { Directionality } from '@angular/cdk/bidi';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject, animationFrameScheduler } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
import * as i2 from "@angular/common";
import * as i3 from "./smooth-scroll.model";
// @dynamic
var SmoothScrollManager = /** @class */ (function () {
    function SmoothScrollManager(_zone, _dir, _document, _platform, customDefaultOptions) {
        this._zone = _zone;
        this._dir = _dir;
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = tslib_1.__assign({ duration: 468, easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            } }, customDefaultOptions);
    }
    Object.defineProperty(SmoothScrollManager.prototype, "_w", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._document.defaultView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmoothScrollManager.prototype, "_now", {
        /**
         * Timing method
         */
        get: /**
         * Timing method
         * @private
         * @return {?}
         */
        function () {
            return this._w.performance && this._w.performance.now
                ? this._w.performance.now.bind(this._w.performance)
                : Date.now;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * changes scroll position inside an element
     */
    /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    SmoothScrollManager.prototype._scrollElement = /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    };
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    SmoothScrollManager.prototype._getElement = /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    function (el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    };
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    SmoothScrollManager.prototype._initSmoothScroll = /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    };
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    SmoothScrollManager.prototype._isFinished = /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    function (context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    };
    /**
     * Terminates an ongoing smooth scroll
     */
    /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    SmoothScrollManager.prototype._interrupted = /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    function (el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    };
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    SmoothScrollManager.prototype._destroy = /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    function (el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    };
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    SmoothScrollManager.prototype._step = /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var elapsed = (_this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            /** @type {?} */
            var value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            _this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule((/**
             * @return {?}
             */
            function () { return observer.next(context); }));
        }));
    };
    /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    SmoothScrollManager.prototype._applyScrollToOptions = /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    function (el, options) {
        var _this = this;
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        /** @type {?} */
        var destroyed = this._initSmoothScroll(el);
        /** @type {?} */
        var easingOptions = options.easing || this._defaultOptions.easing;
        /** @type {?} */
        var context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration || this._defaultOptions.duration,
            easing: BezierEasing(easingOptions.x1, easingOptions.y1, easingOptions.x2, easingOptions.y2)
        };
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        function (resolve) {
            // Scroll each step recursively
            of(null).pipe(expand((/**
             * @return {?}
             */
            function () { return _this._step(context).pipe(takeWhile((/**
             * @param {?} currContext
             * @return {?}
             */
            function (currContext) { return _this._isFinished(currContext, destroyed, resolve); }))); })), takeUntil(_this._interrupted(el, destroyed)), finalize((/**
             * @return {?}
             */
            function () { return _this._destroy(el, destroyed); }))).subscribe();
        }));
    };
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param options specified the offsets to scroll to.
     */
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} options specified the offsets to scroll to.
     * @return {?}
     */
    SmoothScrollManager.prototype.scrollTo = /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} options specified the offsets to scroll to.
     * @return {?}
     */
    function (scrollable, options) {
        if (isPlatformBrowser(this._platform)) {
            /** @type {?} */
            var el = this._getElement(scrollable);
            /** @type {?} */
            var isRtl = getComputedStyle(el).direction === 'rtl';
            /** @type {?} */
            var rtlScrollAxisType = getRtlScrollAxisType();
            // Rewrite start & end offsets as right or left offsets.
            options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;
            options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                ((/** @type {?} */ (options))).top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
                if (options.left != null) {
                    ((/** @type {?} */ (options))).right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    ((/** @type {?} */ (options))).left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
    };
    /**
     * Scroll to element by reference or selector
     */
    /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    SmoothScrollManager.prototype.scrollToElement = /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    function (scrollable, target, options) {
        /** @type {?} */
        var scrollableEl = this._getElement(scrollable);
        /** @type {?} */
        var targetEl = this._getElement(target, scrollableEl);
        /** @type {?} */
        var duration = options.duration;
        /** @type {?} */
        var easing = options.easing;
        return targetEl ? this.scrollTo(scrollableEl, {
            left: targetEl.offsetLeft + (options.left || 0),
            top: targetEl.offsetTop + (options.top || 0),
            duration: duration,
            easing: easing
        }) : new Promise(null);
    };
    SmoothScrollManager.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SmoothScrollManager.ctorParameters = function () { return [
        { type: NgZone },
        { type: Directionality },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
    ]; };
    /** @nocollapse */ SmoothScrollManager.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Directionality), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i3.SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
    return SmoothScrollManager;
}());
export { SmoothScrollManager };
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._defaultOptions;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._onGoingScrolls;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._zone;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._document;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._platform;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsLyIsInNvdXJjZXMiOlsic21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFjLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDOUYsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFaEYsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDMUYsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RSxPQUFPLFlBQVksTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxFQUNMLHFCQUFxQixFQUt0QixNQUFNLHVCQUF1QixDQUFDOzs7Ozs7QUFHL0I7SUEyQkUsNkJBQW9CLEtBQWEsRUFDYixJQUFvQixFQUNGLFNBQWMsRUFDWCxTQUFpQixFQUNILG9CQUEyQztRQUo5RSxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQ2IsU0FBSSxHQUFKLElBQUksQ0FBZ0I7UUFDRixjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQ1gsY0FBUyxHQUFULFNBQVMsQ0FBUTs7Ozs7UUFsQmxELG9CQUFlLEdBQUcsSUFBSSxHQUFHLEVBQThCLENBQUM7UUFvQjlELElBQUksQ0FBQyxlQUFlLHNCQUNsQixRQUFRLEVBQUUsR0FBRyxFQUNiLE1BQU0sRUFBRTtnQkFDTixFQUFFLEVBQUUsSUFBSTtnQkFDUixFQUFFLEVBQUUsQ0FBQztnQkFDTCxFQUFFLEVBQUUsSUFBSTtnQkFDUixFQUFFLEVBQUUsQ0FBQzthQUNOLElBQ0Usb0JBQW9CLENBQ3hCLENBQUM7SUFDSixDQUFDO0lBNUJELHNCQUFZLG1DQUFFOzs7OztRQUFkO1lBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztRQUNwQyxDQUFDOzs7T0FBQTtJQUtELHNCQUFZLHFDQUFJO1FBSGhCOztXQUVHOzs7Ozs7UUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRztnQkFDbkQsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7Z0JBQ25ELENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ2YsQ0FBQzs7O09BQUE7SUFtQkQ7O09BRUc7Ozs7Ozs7OztJQUNLLDRDQUFjOzs7Ozs7OztJQUF0QixVQUF1QixFQUFlLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDMUQsRUFBRSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFDbEIsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVEOztPQUVHOzs7Ozs7OztJQUNLLHlDQUFXOzs7Ozs7O0lBQW5CLFVBQW9CLEVBQXFDLEVBQUUsTUFBb0I7UUFDN0UsSUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQUU7WUFDMUIsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3JEO1FBQ0QsT0FBTyxhQUFhLENBQWMsRUFBRSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOztPQUVHOzs7Ozs7O0lBQ0ssK0NBQWlCOzs7Ozs7SUFBekIsVUFBMEIsRUFBZTtRQUN2QyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3JDO1FBQ0QsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxPQUFPLEVBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7OztJQUNLLHlDQUFXOzs7Ozs7OztJQUFuQixVQUFvQixPQUF5QixFQUFFLFNBQXdCLEVBQUUsT0FBbUI7UUFDMUYsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLENBQUMsQ0FBQyxFQUFFO1lBQ3BFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDakIsT0FBTyxFQUFFLENBQUM7UUFDVixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRzs7Ozs7Ozs7SUFDSywwQ0FBWTs7Ozs7OztJQUFwQixVQUFxQixFQUFlLEVBQUUsU0FBd0I7UUFDNUQsT0FBTyxLQUFLLENBQ1YsU0FBUyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUN4RCxTQUFTLENBQUMsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQzVELFNBQVMsQ0FDVixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7O0lBQ0ssc0NBQVE7Ozs7Ozs7SUFBaEIsVUFBaUIsRUFBZSxFQUFFLFNBQXdCO1FBQ3hELFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7SUFDSyxtQ0FBSzs7Ozs7O0lBQWIsVUFBYyxPQUF5QjtRQUF2QyxpQkFpQkM7UUFoQkMsT0FBTyxJQUFJLFVBQVU7Ozs7UUFBQyxVQUFBLFFBQVE7O2dCQUN4QixPQUFPLEdBQUcsQ0FBQyxLQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFRO1lBRWxFLHNDQUFzQztZQUN0QyxPQUFPLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7OztnQkFHOUIsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBRXJDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUN6RSxPQUFPLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUM7WUFFekUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVFLHNCQUFzQjtZQUN0Qix1QkFBdUIsQ0FBQyxRQUFROzs7WUFBQyxjQUFNLE9BQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBdEIsQ0FBc0IsRUFBQyxDQUFDO1FBQ2pFLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7OztJQUVPLG1EQUFxQjs7Ozs7O0lBQTdCLFVBQThCLEVBQWUsRUFBRSxPQUE4QjtRQUE3RSxpQkFnQ0M7UUEvQkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUU7WUFDckIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbkQsT0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDMUI7OztZQUdLLFNBQVMsR0FBa0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQzs7WUFFckQsYUFBYSxHQUFHLE9BQU8sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNOztZQUU3RCxPQUFPLEdBQXFCO1lBQ2hDLFVBQVUsRUFBRSxFQUFFO1lBQ2QsU0FBUyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDdEIsTUFBTSxFQUFFLEVBQUUsQ0FBQyxVQUFVO1lBQ3JCLE1BQU0sRUFBRSxFQUFFLENBQUMsU0FBUztZQUNwQixDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSTtZQUN4RCxDQUFDLEVBQUUsT0FBTyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRztZQUNyRCxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVE7WUFDM0QsTUFBTSxFQUFFLFlBQVksQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLGFBQWEsQ0FBQyxFQUFFLEVBQUUsYUFBYSxDQUFDLEVBQUUsRUFBRSxhQUFhLENBQUMsRUFBRSxDQUFDO1NBQzdGO1FBRUQsT0FBTyxJQUFJLE9BQU87Ozs7UUFBQyxVQUFBLE9BQU87WUFDeEIsK0JBQStCO1lBQy9CLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQ1gsTUFBTTs7O1lBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNuQyxTQUFTOzs7O1lBQUMsVUFBQyxXQUE2QixJQUFLLE9BQUEsS0FBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxFQUFqRCxDQUFpRCxFQUFDLENBQ2hHLEVBRlksQ0FFWixFQUFDLEVBQ0YsU0FBUyxDQUFDLEtBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQzNDLFFBQVE7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsRUFBNUIsQ0FBNEIsRUFBQyxDQUM3QyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2hCLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQztJQUdEOzs7Ozs7OztPQVFHOzs7Ozs7Ozs7OztJQUNILHNDQUFROzs7Ozs7Ozs7O0lBQVIsVUFBUyxVQUErQixFQUFFLE9BQThCO1FBQ3RFLElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFOztnQkFDL0IsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDOztnQkFDakMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsS0FBSyxLQUFLOztnQkFDaEQsaUJBQWlCLEdBQUcsb0JBQW9CLEVBQUU7WUFFaEQsd0RBQXdEO1lBQ3hELE9BQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7WUFDM0YsT0FBTyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztZQUU5Riw2Q0FBNkM7WUFDN0MsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRTtnQkFDMUIsQ0FBQyxtQkFBQSxPQUFPLEVBQTRCLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7YUFDaEc7WUFFRCw2Q0FBNkM7WUFDN0MsSUFBSSxLQUFLLElBQUksaUJBQWlCLEtBQUssaUJBQWlCLENBQUMsTUFBTSxFQUFFO2dCQUMzRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFO29CQUN4QixDQUFDLG1CQUFBLE9BQU8sRUFBNEIsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztpQkFDOUY7Z0JBRUQsSUFBSSxpQkFBaUIsS0FBSyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUU7b0JBQ3BELE9BQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztpQkFDOUI7cUJBQU0sSUFBSSxpQkFBaUIsS0FBSyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUU7b0JBQzFELE9BQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO2lCQUMvRDthQUNGO2lCQUFNO2dCQUNMLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7b0JBQ3pCLENBQUMsbUJBQUEsT0FBTyxFQUE0QixDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO2lCQUM5RjthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2hEO0lBQ0gsQ0FBQztJQUVEOztPQUVHOzs7Ozs7OztJQUNILDZDQUFlOzs7Ozs7O0lBQWYsVUFBZ0IsVUFBK0IsRUFBRSxNQUEyQixFQUFFLE9BQTJDOztZQUNqSCxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUM7O1lBQzNDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUM7O1lBQ2pELFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUTs7WUFDM0IsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNO1FBQzdCLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRTtZQUM1QyxJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1lBQy9DLEdBQUcsRUFBRSxRQUFRLENBQUMsU0FBUyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDNUMsUUFBUSxVQUFBO1lBQ1IsTUFBTSxRQUFBO1NBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QixDQUFDOztnQkExTkYsVUFBVSxTQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7OztnQkFwQitELE1BQU07Z0JBRzdELGNBQWM7Z0RBNENSLE1BQU0sU0FBQyxRQUFROzZDQUNmLE1BQU0sU0FBQyxXQUFXO2dEQUNsQixRQUFRLFlBQUksTUFBTSxTQUFDLHFCQUFxQjs7OzhCQWpEdkQ7Q0E2T0MsQUEzTkQsSUEyTkM7U0F4TlksbUJBQW1COzs7Ozs7SUFHOUIsOENBQStDOzs7OztJQU0vQyw4Q0FBZ0U7Ozs7O0lBZXBELG9DQUFxQjs7Ozs7SUFDckIsbUNBQTRCOzs7OztJQUM1Qix3Q0FBd0M7Ozs7O0lBQ3hDLHdDQUE4QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIE9wdGlvbmFsLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQgeyBnZXRSdGxTY3JvbGxBeGlzVHlwZSwgUnRsU2Nyb2xsQXhpc1R5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xyXG5pbXBvcnQgeyBfQm90dG9tLCBfTGVmdCwgX1JpZ2h0LCBfVG9wLCBfV2l0aG91dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBvZiwgT2JzZXJ2YWJsZSwgU3ViamVjdCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZXhwYW5kLCBmaW5hbGl6ZSwgdGFrZSwgdGFrZVVudGlsLCB0YWtlV2hpbGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCBCZXppZXJFYXNpbmcgZnJvbSAnYmV6aWVyLWVhc2luZyc7XHJcbmltcG9ydCB7XHJcbiAgU01PT1RIX1NDUk9MTF9PUFRJT05TLFxyXG4gIFNtb290aFNjcm9sbEVsZW1lbnQsXHJcbiAgU21vb3RoU2Nyb2xsT3B0aW9ucyxcclxuICBTbW9vdGhTY3JvbGxTdGVwLFxyXG4gIFNtb290aFNjcm9sbFRvT3B0aW9uc1xyXG59IGZyb20gJy4vc21vb3RoLXNjcm9sbC5tb2RlbCc7XHJcblxyXG4vLyBAZHluYW1pY1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTbW9vdGhTY3JvbGxNYW5hZ2VyIHtcclxuXHJcbiAgLy8gRGVmYXVsdCBvcHRpb25zXHJcbiAgcHJpdmF0ZSBfZGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucztcclxuXHJcbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG9uZ29pbmcgU21vb3RoU2Nyb2xsIGZ1bmN0aW9ucyBzbyB0aGV5IGNhbiBiZSBoYW5kbGVkIGluIGNhc2Ugb2YgZHVwbGljYXRpb24uXHJcbiAgLy8gRWFjaCBzY3JvbGxlZCBlbGVtZW50IGdldHMgYSBkZXN0cm95ZXIgc3RyZWFtIHdoaWNoIGdldHMgZGVsZXRlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBjb21wbGV0ZXMuXHJcbiAgLy8gUHVycG9zZTogSWYgdXNlciBjYWxsZWQgYSBzY3JvbGwgZnVuY3Rpb24gYWdhaW4gb24gdGhlIHNhbWUgZWxlbWVudCBiZWZvcmUgdGhlIHNjcm9sbHMgY29tcGxldGVzLFxyXG4gIC8vIGl0IGNhbmNlbHMgdGhlIG9uZ29pbmcgc2Nyb2xsIGFuZCBzdGFydHMgYSBuZXcgb25lXHJcbiAgcHJpdmF0ZSBfb25Hb2luZ1Njcm9sbHMgPSBuZXcgTWFwPEhUTUxFbGVtZW50LCBTdWJqZWN0PHZvaWQ+PigpO1xyXG5cclxuICBwcml2YXRlIGdldCBfdygpOiBhbnkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltaW5nIG1ldGhvZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ub3coKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdy5wZXJmb3JtYW5jZSAmJiB0aGlzLl93LnBlcmZvcm1hbmNlLm5vd1xyXG4gICAgICA/IHRoaXMuX3cucGVyZm9ybWFuY2Uubm93LmJpbmQodGhpcy5fdy5wZXJmb3JtYW5jZSlcclxuICAgICAgOiBEYXRlLm5vdztcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3pvbmU6IE5nWm9uZSxcclxuICAgICAgICAgICAgICBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5LFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICAgICAgICAgICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBfcGxhdGZvcm06IG9iamVjdCxcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFNNT09USF9TQ1JPTExfT1BUSU9OUykgY3VzdG9tRGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucykge1xyXG4gICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgIGR1cmF0aW9uOiA0NjgsXHJcbiAgICAgIGVhc2luZzoge1xyXG4gICAgICAgIHgxOiAwLjQyLFxyXG4gICAgICAgIHkxOiAwLFxyXG4gICAgICAgIHgyOiAwLjU4LFxyXG4gICAgICAgIHkyOiAxXHJcbiAgICAgIH0sXHJcbiAgICAgIC4uLmN1c3RvbURlZmF1bHRPcHRpb25zLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc2Nyb2xsRWxlbWVudChlbDogSFRNTEVsZW1lbnQsIHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBlbC5zY3JvbGxMZWZ0ID0geDtcclxuICAgIGVsLnNjcm9sbFRvcCA9IHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgZ2l2ZW4gcGFyYW1ldGVyIG9mIHR5cGUgSFRNTEVsZW1lbnQsIEVsZW1lbnRSZWYgb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRFbGVtZW50KGVsOiBIVE1MRWxlbWVudCB8IEVsZW1lbnRSZWYgfCBzdHJpbmcsIHBhcmVudD86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xyXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIChwYXJlbnQgfHwgdGhpcy5fZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZXJjZUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KGVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGEgZGVzdHJveWVyIHN0cmVhbSwgcmUtaW5pdGlhbGl6ZXMgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2luaXRTbW9vdGhTY3JvbGwoZWw6IEhUTUxFbGVtZW50KTogU3ViamVjdDx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5fb25Hb2luZ1Njcm9sbHMuaGFzKGVsKSkge1xyXG4gICAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5nZXQoZWwpLm5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9vbkdvaW5nU2Nyb2xscy5zZXQoZWwsIG5ldyBTdWJqZWN0PHZvaWQ+KCkpLmdldChlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgc21vb3RoIHNjcm9sbCBoYXMgcmVhY2hlZCwgY2xlYW5zIHVwIHRoZSBzbW9vdGggc2Nyb2xsIHN0cmVhbSBhbmQgcmVzb2x2ZXMgaXRzIHByb21pc2VcclxuICAgKi9cclxuICBwcml2YXRlIF9pc0ZpbmlzaGVkKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiwgcmVzb2x2ZTogKCkgPT4gdm9pZCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGNvbnRleHQuY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjb250ZXh0LmN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95ZWQubmV4dCgpO1xyXG4gICAgcmVzb2x2ZSgpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVybWluYXRlcyBhbiBvbmdvaW5nIHNtb290aCBzY3JvbGxcclxuICAgKi9cclxuICBwcml2YXRlIF9pbnRlcnJ1cHRlZChlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gbWVyZ2UoXHJcbiAgICAgIGZyb21FdmVudChlbCwgJ3doZWVsJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICBmcm9tRXZlbnQoZWwsICd0b3VjaG1vdmUnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXHJcbiAgICAgIGRlc3Ryb3llZFxyXG4gICAgKS5waXBlKHRha2UoMSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyB0aGUgZGVzdHJveWVyIGZ1bmN0aW9uLCBydW5zIGlmIHRoZSBzbW9vdGggc2Nyb2xsIGhhcyBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2Rlc3Ryb3koZWw6IEhUTUxFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiB2b2lkIHtcclxuICAgIGRlc3Ryb3llZC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fb25Hb2luZ1Njcm9sbHMuZGVsZXRlKGVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZnVuY3Rpb24gY2FsbGVkIHJlY3Vyc2l2ZWx5IHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcclxuICAgKi9cclxuICBwcml2YXRlIF9zdGVwKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApOiBPYnNlcnZhYmxlPFNtb290aFNjcm9sbFN0ZXA+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XHJcbiAgICAgIGxldCBlbGFwc2VkID0gKHRoaXMuX25vdygpIC0gY29udGV4dC5zdGFydFRpbWUpIC8gY29udGV4dC5kdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXHJcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xyXG5cclxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHQuZWFzaW5nKGVsYXBzZWQpO1xyXG5cclxuICAgICAgY29udGV4dC5jdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xyXG4gICAgICBjb250ZXh0LmN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XHJcblxyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGNvbnRleHQuc2Nyb2xsYWJsZSwgY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XHJcbiAgICAgIC8vIFByb2NlZWQgdG8gdGhlIHN0ZXBcclxuICAgICAgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4gb2JzZXJ2ZXIubmV4dChjb250ZXh0KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChlbCwgb3B0aW9ucy5sZWZ0LCBvcHRpb25zLnRvcCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGEgZGVzdHJveWVyIHN0cmVhbSwgcmVpbml0aWFsaXplIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgIGNvbnN0IGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IHRoaXMuX2luaXRTbW9vdGhTY3JvbGwoZWwpO1xyXG5cclxuICAgIGNvbnN0IGVhc2luZ09wdGlvbnMgPSBvcHRpb25zLmVhc2luZyB8fCB0aGlzLl9kZWZhdWx0T3B0aW9ucy5lYXNpbmc7XHJcblxyXG4gICAgY29uc3QgY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCA9IHtcclxuICAgICAgc2Nyb2xsYWJsZTogZWwsXHJcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5fbm93KCksXHJcbiAgICAgIHN0YXJ0WDogZWwuc2Nyb2xsTGVmdCxcclxuICAgICAgc3RhcnRZOiBlbC5zY3JvbGxUb3AsXHJcbiAgICAgIHg6IG9wdGlvbnMubGVmdCA9PSBudWxsID8gZWwuc2Nyb2xsTGVmdCA6IH5+b3B0aW9ucy5sZWZ0LFxyXG4gICAgICB5OiBvcHRpb25zLnRvcCA9PSBudWxsID8gZWwuc2Nyb2xsVG9wIDogfn5vcHRpb25zLnRvcCxcclxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24gfHwgdGhpcy5fZGVmYXVsdE9wdGlvbnMuZHVyYXRpb24sXHJcbiAgICAgIGVhc2luZzogQmV6aWVyRWFzaW5nKGVhc2luZ09wdGlvbnMueDEsIGVhc2luZ09wdGlvbnMueTEsIGVhc2luZ09wdGlvbnMueDIsIGVhc2luZ09wdGlvbnMueTIpXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgLy8gU2Nyb2xsIGVhY2ggc3RlcCByZWN1cnNpdmVseVxyXG4gICAgICBvZihudWxsKS5waXBlKFxyXG4gICAgICAgIGV4cGFuZCgoKSA9PiB0aGlzLl9zdGVwKGNvbnRleHQpLnBpcGUoXHJcbiAgICAgICAgICB0YWtlV2hpbGUoKGN1cnJDb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKSA9PiB0aGlzLl9pc0ZpbmlzaGVkKGN1cnJDb250ZXh0LCBkZXN0cm95ZWQsIHJlc29sdmUpKVxyXG4gICAgICAgICkpLFxyXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9pbnRlcnJ1cHRlZChlbCwgZGVzdHJveWVkKSksXHJcbiAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5fZGVzdHJveShlbCwgZGVzdHJveWVkKSlcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXRzLiBUaGlzIGlzIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNjcm9sbFRvXHJcbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXHJcbiAgICogbGVmdCBhbmQgcmlnaHQgYWx3YXlzIHJlZmVyIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlycmVzcGVjdGl2ZVxyXG4gICAqIG9mIHRoZSBsYXlvdXQgZGlyZWN0aW9uLiBzdGFydCBhbmQgZW5kIHJlZmVyIHRvIGxlZnQgYW5kIHJpZ2h0IGluIGFuIExUUiBjb250ZXh0IGFuZCB2aWNlLXZlcnNhXHJcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHNwZWNpZmllZCB0aGUgb2Zmc2V0cyB0byBzY3JvbGwgdG8uXHJcbiAgICovXHJcbiAgc2Nyb2xsVG8oc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm0pKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgICAgY29uc3QgaXNSdGwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb24gPT09ICdydGwnO1xyXG4gICAgICBjb25zdCBydGxTY3JvbGxBeGlzVHlwZSA9IGdldFJ0bFNjcm9sbEF4aXNUeXBlKCk7XHJcblxyXG4gICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxyXG4gICAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLmxlZnQgPT0gbnVsbCA/IChpc1J0bCA/IG9wdGlvbnMuZW5kIDogb3B0aW9ucy5zdGFydCkgOiBvcHRpb25zLmxlZnQ7XHJcbiAgICAgIG9wdGlvbnMucmlnaHQgPSBvcHRpb25zLnJpZ2h0ID09IG51bGwgPyAoaXNSdGwgPyBvcHRpb25zLnN0YXJ0IDogb3B0aW9ucy5lbmQpIDogb3B0aW9ucy5yaWdodDtcclxuXHJcbiAgICAgIC8vIFJld3JpdGUgdGhlIGJvdHRvbSBvZmZzZXQgYXMgYSB0b3Agb2Zmc2V0LlxyXG4gICAgICBpZiAob3B0aW9ucy5ib3R0b20gIT0gbnVsbCkge1xyXG4gICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9Cb3R0b20+ICYgX1RvcCkudG9wID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0IC0gb3B0aW9ucy5ib3R0b207XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJld3JpdGUgdGhlIHJpZ2h0IG9mZnNldCBhcyBhIGxlZnQgb2Zmc2V0LlxyXG4gICAgICBpZiAoaXNSdGwgJiYgcnRsU2Nyb2xsQXhpc1R5cGUgIT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5PUk1BTCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0xlZnQ+ICYgX1JpZ2h0KS5yaWdodCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLmxlZnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQpIHtcclxuICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQgPyAtb3B0aW9ucy5yaWdodCA6IG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0ICE9IG51bGwpIHtcclxuICAgICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9SaWdodD4gJiBfTGVmdCkubGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTY3JvbGxUb09wdGlvbnMoZWwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHRvIGVsZW1lbnQgYnkgcmVmZXJlbmNlIG9yIHNlbGVjdG9yXHJcbiAgICovXHJcbiAgc2Nyb2xsVG9FbGVtZW50KHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIHRhcmdldDogU21vb3RoU2Nyb2xsRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsT3B0aW9ucyAmIF9Ub3AgJiBfTGVmdCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5fZ2V0RWxlbWVudCh0YXJnZXQsIHNjcm9sbGFibGVFbCk7XHJcbiAgICBjb25zdCBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XHJcbiAgICBjb25zdCBlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcclxuICAgIHJldHVybiB0YXJnZXRFbCA/IHRoaXMuc2Nyb2xsVG8oc2Nyb2xsYWJsZUVsLCB7XHJcbiAgICAgIGxlZnQ6IHRhcmdldEVsLm9mZnNldExlZnQgKyAob3B0aW9ucy5sZWZ0IHx8IDApLFxyXG4gICAgICB0b3A6IHRhcmdldEVsLm9mZnNldFRvcCArIChvcHRpb25zLnRvcCB8fCAwKSxcclxuICAgICAgZHVyYXRpb24sXHJcbiAgICAgIGVhc2luZ1xyXG4gICAgfSkgOiBuZXcgUHJvbWlzZShudWxsKTtcclxuICB9XHJcbn1cclxuXHJcbiJdfQ==