/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, Optional, Input, Output, NgZone } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { RtlScrollAxisType } from '@angular/cdk/platform';
import { Observable, Subject, Subscription } from 'rxjs';
import { filter, map, tap, distinctUntilChanged } from 'rxjs/operators';
import { NgScrollbar } from 'ngx-scrollbar';
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
var 
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
ReachedFunctions = /** @class */ (function () {
    function ReachedFunctions() {
    }
    /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    ReachedFunctions.reachedTop = /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    };
    /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    ReachedFunctions.reachedBottom = /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    };
    /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    ReachedFunctions.reachedStart = /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    function (offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    };
    /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    ReachedFunctions.reachedEnd = /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    function (offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    };
    /**
     * @param {?} currPosition
     * @param {?} targetPosition
     * @param {?} offset
     * @return {?}
     */
    ReachedFunctions.reached = /**
     * @param {?} currPosition
     * @param {?} targetPosition
     * @param {?} offset
     * @return {?}
     */
    function (currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    };
    return ReachedFunctions;
}());
/**
 * @abstract
 */
var ScrollReached = /** @class */ (function () {
    function ScrollReached(scrollbar, zone) {
        var _this = this;
        this.scrollbar = scrollbar;
        this.zone = zone;
        /**
         * offset: Reached offset value in px
         */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /**
         * subscription: Scrolled event subscription, used to unsubscribe from the event on destroy
         */
        this.subscription = Subscription.EMPTY;
        /**
         * A stream used to assign the reached output
         */
        this.reachedEvent = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            return _this.scrollReached().subscribe((/**
             * @param {?} _
             * @return {?}
             */
            function (_) {
                return Promise.resolve().then((/**
                 * @return {?}
                 */
                function () { return _this.zone.run((/**
                 * @return {?}
                 */
                function () { return observer.next(_); })); }));
            }));
        }));
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    /**
     * @return {?}
     */
    ScrollReached.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @protected
     * @return {?}
     */
    ScrollReached.prototype.scrollReached = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        // current event
        /** @type {?} */
        var currEvent;
        return this.scrollEvent.pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return currEvent = e; })), 
        // Check if it scroll has reached
        map((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.reached(_this.offset, e); })), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((/**
         * @param {?} reached
         * @return {?}
         */
        function (reached) { return reached; })), 
        // Return scroll event
        map((/**
         * @return {?}
         */
        function () { return currEvent; })));
    };
    ScrollReached.propDecorators = {
        offset: [{ type: Input, args: ['reachedOffset',] }]
    };
    return ScrollReached;
}());
if (false) {
    /**
     * offset: Reached offset value in px
     * @type {?}
     */
    ScrollReached.prototype.offset;
    /**
     * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
     *
     * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.scrollEvent;
    /**
     * subscription: Scrolled event subscription, used to unsubscribe from the event on destroy
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.subscription;
    /**
     * A stream used to assign the reached output
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.reachedEvent;
    /**
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.zone;
    /**
     * @abstract
     * @protected
     * @param {?} offset
     * @param {?=} e
     * @return {?}
     */
    ScrollReached.prototype.reached = function (offset, e) { };
}
/**
 * @abstract
 */
var VerticalScrollReached = /** @class */ (function (_super) {
    tslib_1.__extends(VerticalScrollReached, _super);
    function VerticalScrollReached(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        return _this;
    }
    /**
     * @return {?}
     */
    VerticalScrollReached.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    };
    /** @nocollapse */
    VerticalScrollReached.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    return VerticalScrollReached;
}(ScrollReached));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollReached.prototype.zone;
}
/**
 * @abstract
 */
var HorizontalScrollReached = /** @class */ (function (_super) {
    tslib_1.__extends(HorizontalScrollReached, _super);
    function HorizontalScrollReached(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        return _this;
    }
    /**
     * @return {?}
     */
    HorizontalScrollReached.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    };
    /** @nocollapse */
    HorizontalScrollReached.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    return HorizontalScrollReached;
}(ScrollReached));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollReached.prototype.zone;
}
var NgScrollbarReachedTop = /** @class */ (function (_super) {
    tslib_1.__extends(NgScrollbarReachedTop, _super);
    function NgScrollbarReachedTop(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        /**
         * Stream that emits when scroll has reached the top
         */
        _this.reachedTop = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedTop.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the top (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedTop.prototype.reached = /**
     * Check if scroll has reached the top (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    };
    NgScrollbarReachedTop.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedTop], [reached-top]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedTop.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    NgScrollbarReachedTop.propDecorators = {
        reachedTop: [{ type: Output }]
    };
    return NgScrollbarReachedTop;
}(VerticalScrollReached));
export { NgScrollbarReachedTop };
if (false) {
    /**
     * Stream that emits when scroll has reached the top
     * @type {?}
     */
    NgScrollbarReachedTop.prototype.reachedTop;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedTop.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedTop.prototype.zone;
}
var NgScrollbarReachedBottom = /** @class */ (function (_super) {
    tslib_1.__extends(NgScrollbarReachedBottom, _super);
    function NgScrollbarReachedBottom(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        /**
         * Stream that emits when scroll has reached the bottom
         */
        _this.reachedBottom = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedBottom.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the bottom (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedBottom.prototype.reached = /**
     * Check if scroll has reached the bottom (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    };
    NgScrollbarReachedBottom.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedBottom], [reached-bottom]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedBottom.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    NgScrollbarReachedBottom.propDecorators = {
        reachedBottom: [{ type: Output }]
    };
    return NgScrollbarReachedBottom;
}(VerticalScrollReached));
export { NgScrollbarReachedBottom };
if (false) {
    /**
     * Stream that emits when scroll has reached the bottom
     * @type {?}
     */
    NgScrollbarReachedBottom.prototype.reachedBottom;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedBottom.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedBottom.prototype.zone;
}
var NgScrollbarReachedStart = /** @class */ (function (_super) {
    tslib_1.__extends(NgScrollbarReachedStart, _super);
    function NgScrollbarReachedStart(scrollbar, zone, dir) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        _this.dir = dir;
        /**
         * Stream that emits when scroll has reached the start
         */
        _this.reachedStart = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedStart.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the start (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedStart.prototype.reached = /**
     * Check if scroll has reached the start (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    };
    NgScrollbarReachedStart.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedStart], [reached-start]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedStart.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone },
        { type: Directionality }
    ]; };
    NgScrollbarReachedStart.propDecorators = {
        reachedStart: [{ type: Output }]
    };
    return NgScrollbarReachedStart;
}(HorizontalScrollReached));
export { NgScrollbarReachedStart };
if (false) {
    /**
     * Stream that emits when scroll has reached the start
     * @type {?}
     */
    NgScrollbarReachedStart.prototype.reachedStart;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedStart.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedStart.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbarReachedStart.prototype.dir;
}
var NgScrollbarReachedEnd = /** @class */ (function (_super) {
    tslib_1.__extends(NgScrollbarReachedEnd, _super);
    function NgScrollbarReachedEnd(scrollbar, zone, dir) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        _this.dir = dir;
        /**
         * Stream that emits when scroll has reached the end
         */
        _this.reachedEnd = _this.reachedEvent;
        return _this;
    }
    /**
     * @return {?}
     */
    NgScrollbarReachedEnd.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    /**
     * Check if scroll has reached the end (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    NgScrollbarReachedEnd.prototype.reached = /**
     * Check if scroll has reached the end (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    function (offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    };
    NgScrollbarReachedEnd.decorators = [
        { type: Directive, args: [{
                    selector: '[reachedEnd], [reached-end]',
                },] }
    ];
    /** @nocollapse */
    NgScrollbarReachedEnd.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone },
        { type: Directionality }
    ]; };
    NgScrollbarReachedEnd.propDecorators = {
        reachedEnd: [{ type: Output }]
    };
    return NgScrollbarReachedEnd;
}(HorizontalScrollReached));
export { NgScrollbarReachedEnd };
if (false) {
    /**
     * Stream that emits when scroll has reached the end
     * @type {?}
     */
    NgScrollbarReachedEnd.prototype.reachedEnd;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedEnd.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedEnd.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbarReachedEnd.prototype.dir;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLXJlYWNoZWQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtc2Nyb2xsYmFyL3JlYWNoZWQtZXZlbnQvIiwic291cmNlcyI6WyJuZy1zY3JvbGxiYXItcmVhY2hlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQXFCLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFZLE1BQU0sTUFBTSxDQUFDO0FBQ25FLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7OztBQUk1Qzs7OztJQUFBO0lBc0NBLENBQUM7Ozs7OztJQXJDUSwyQkFBVTs7Ozs7SUFBakIsVUFBa0IsTUFBYyxFQUFFLENBQU07UUFDdEMsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDbEUsQ0FBQzs7Ozs7O0lBRU0sOEJBQWE7Ozs7O0lBQXBCLFVBQXFCLE1BQWMsRUFBRSxDQUFNO1FBQ3pDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdHLENBQUM7Ozs7Ozs7O0lBRU0sNkJBQVk7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Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCwgSW5wdXQsIE91dHB1dCwgT25Jbml0LCBPbkRlc3Ryb3ksIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHsgUnRsU2Nyb2xsQXhpc1R5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGZpbHRlciwgbWFwLCB0YXAsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBOZ1Njcm9sbGJhciB9IGZyb20gJ25neC1zY3JvbGxiYXInO1xyXG4vLyBVbmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lIGluIGRldmVsb3BtZW50IG1vZGVcclxuLy8gaW1wb3J0IHsgTmdTY3JvbGxiYXIgfSBmcm9tICcuLi8uLi9zcmMvcHVibGljLWFwaSc7XHJcblxyXG5jbGFzcyBSZWFjaGVkRnVuY3Rpb25zIHtcclxuICBzdGF0aWMgcmVhY2hlZFRvcChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxUb3AsIDAsIG9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcmVhY2hlZEJvdHRvbShvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbFRvcCArIGUudGFyZ2V0LmNsaWVudEhlaWdodCwgZS50YXJnZXQuc2Nyb2xsSGVpZ2h0LCBvZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHJlYWNoZWRTdGFydChvZmZzZXQ6IG51bWJlciwgZTogYW55LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZChlLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoLCBlLnRhcmdldC5zY3JvbGxXaWR0aCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcmVhY2hlZEVuZChvZmZzZXQ6IG51bWJlciwgZTogYW55LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtKGUudGFyZ2V0LnNjcm9sbExlZnQgLSBlLnRhcmdldC5jbGllbnRXaWR0aCksIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC0oZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoKSwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtZS50YXJnZXQuc2Nyb2xsTGVmdCwgMCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoLCBlLnRhcmdldC5zY3JvbGxXaWR0aCwgb2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyByZWFjaGVkKGN1cnJQb3NpdGlvbjogbnVtYmVyLCB0YXJnZXRQb3NpdGlvbjogbnVtYmVyLCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGN1cnJQb3NpdGlvbiA+PSB0YXJnZXRQb3NpdGlvbiAtIG9mZnNldDtcclxuICB9XHJcbn1cclxuXHJcbmFic3RyYWN0IGNsYXNzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xyXG5cclxuICAvKiogb2Zmc2V0OiBSZWFjaGVkIG9mZnNldCB2YWx1ZSBpbiBweCAqL1xyXG4gIEBJbnB1dCgncmVhY2hlZE9mZnNldCcpIG9mZnNldCA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0cmVhbSB0aGF0IGVtaXRzIHNjcm9sbCBldmVudCB3aGVuIGBOZ1Njcm9sbGJhci5zY3JvbGxlZGAgaXMgaW5pdGlhbGl6ZWQuXHJcbiAgICpcclxuICAgKiAqKk5PVEU6KiogVGhpcyBzdWJqZWN0IGlzIHVzZWQgdG8gaG9sZCB0aGUgcGxhY2Ugb2YgYE5nU2Nyb2xsYmFyLnNjcm9sbGVkYCB3aGVuIGl0J3Mgbm90IGluaXRpYWxpemVkIHlldFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBzY3JvbGxFdmVudCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcclxuXHJcbiAgLyoqIHN1YnNjcmlwdGlvbjogU2Nyb2xsZWQgZXZlbnQgc3Vic2NyaXB0aW9uLCB1c2VkIHRvIHVuc3Vic2NyaWJlIGZyb20gdGhlIGV2ZW50IG9uIGRlc3Ryb3kgKi9cclxuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICAvKiogQSBzdHJlYW0gdXNlZCB0byBhc3NpZ24gdGhlIHJlYWNoZWQgb3V0cHV0ICovXHJcbiAgcHJvdGVjdGVkIHJlYWNoZWRFdmVudCA9IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcjogT2JzZXJ2ZXI8YW55PikgPT5cclxuICAgIHRoaXMuc2Nyb2xsUmVhY2hlZCgpLnN1YnNjcmliZShfID0+XHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy56b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KF8pKSkpKTtcclxuXHJcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lKSB7XHJcbiAgICBpZiAoIXNjcm9sbGJhcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tOZ1Njcm9sbGJhclJlYWNoZWQgRGlyZWN0aXZlXTogSG9zdCBlbGVtZW50IG11c3QgYmUgYW4gTmdTY3JvbGxiYXIgY29tcG9uZW50LicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNjcm9sbFJlYWNoZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIC8vIGN1cnJlbnQgZXZlbnRcclxuICAgIGxldCBjdXJyRXZlbnQ6IGFueTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxFdmVudC5waXBlKFxyXG4gICAgICB0YXAoKGUpID0+IGN1cnJFdmVudCA9IGUpLFxyXG4gICAgICAvLyBDaGVjayBpZiBpdCBzY3JvbGwgaGFzIHJlYWNoZWRcclxuICAgICAgbWFwKChlKSA9PiB0aGlzLnJlYWNoZWQodGhpcy5vZmZzZXQsIGUpKSxcclxuICAgICAgLy8gRGlzdGluY3QgdW50aWwgcmVhY2hlZCB2YWx1ZSBoYXMgY2hhbmdlZFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICAvLyBFbWl0IG9ubHkgaWYgcmVhY2hlZCBpcyB0cnVlXHJcbiAgICAgIGZpbHRlcigocmVhY2hlZDogYm9vbGVhbikgPT4gcmVhY2hlZCksXHJcbiAgICAgIC8vIFJldHVybiBzY3JvbGwgZXZlbnRcclxuICAgICAgbWFwKCgpID0+IGN1cnJFdmVudClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZT86IGFueSk6IGJvb2xlYW47XHJcbn1cclxuXHJcbmFic3RyYWN0IGNsYXNzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbGJhci52ZXJ0aWNhbFNjcm9sbGVkLnN1YnNjcmliZSh0aGlzLnNjcm9sbEV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmFic3RyYWN0IGNsYXNzIEhvcml6b250YWxTY3JvbGxSZWFjaGVkIGV4dGVuZHMgU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lKSB7XHJcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsYmFyLmhvcml6b250YWxTY3JvbGxlZC5zdWJzY3JpYmUodGhpcy5zY3JvbGxFdmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkVG9wXSwgW3JlYWNoZWQtdG9wXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRUb3AgZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAqL1xyXG4gIEBPdXRwdXQoKSByZWFjaGVkVG9wOiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHN1cGVyLm5nT25Jbml0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAodmVydGljYWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkVG9wKG9mZnNldCwgZSk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkQm90dG9tXSwgW3JlYWNoZWQtYm90dG9tXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRCb3R0b20gZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGJvdHRvbSAqL1xyXG4gIEBPdXRwdXQoKSByZWFjaGVkQm90dG9tOiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHN1cGVyLm5nT25Jbml0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGJvdHRvbSAodmVydGljYWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkQm90dG9tKG9mZnNldCwgZSk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkU3RhcnRdLCBbcmVhY2hlZC1zdGFydF0nLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkU3RhcnQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKi9cclxuICBAT3V0cHV0KCkgcmVhY2hlZFN0YXJ0OiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUsIHByaXZhdGUgZGlyOiBEaXJlY3Rpb25hbGl0eSkge1xyXG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgc3VwZXIubmdPbkluaXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKGhvcml6b250YWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkU3RhcnQob2Zmc2V0LCBlLCB0aGlzLmRpci52YWx1ZSwgdGhpcy5zY3JvbGxiYXIubWFuYWdlci5ydGxTY3JvbGxBeGlzVHlwZSk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkRW5kXSwgW3JlYWNoZWQtZW5kXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRFbmQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgZW5kICovXHJcbiAgQE91dHB1dCgpIHJlYWNoZWRFbmQ6IE9ic2VydmFibGU8YW55PiA9IHRoaXMucmVhY2hlZEV2ZW50O1xyXG5cclxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSwgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5KSB7XHJcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBlbmQgKGhvcml6b250YWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkRW5kKG9mZnNldCwgZSwgdGhpcy5kaXIudmFsdWUsIHRoaXMuc2Nyb2xsYmFyLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUpO1xyXG4gIH1cclxufVxyXG4iXX0=