import { InjectionToken, Injectable, NgZone, Inject, PLATFORM_ID, Optional, ɵɵdefineInjectable, ɵɵinject, Directive, ElementRef, NgModule } from '@angular/core';
import { isPlatformBrowser, DOCUMENT } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { Directionality } from '@angular/cdk/bidi';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';
import { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');
/**
 * @record
 */
function SmoothScrollOptions() { }
if (false) {
    /** @type {?|undefined} */
    SmoothScrollOptions.prototype.duration;
    /** @type {?|undefined} */
    SmoothScrollOptions.prototype.easing;
}
/**
 * @record
 */
function SmoothScrollStep() { }
if (false) {
    /** @type {?} */
    SmoothScrollStep.prototype.scrollable;
    /** @type {?} */
    SmoothScrollStep.prototype.startTime;
    /** @type {?} */
    SmoothScrollStep.prototype.startX;
    /** @type {?} */
    SmoothScrollStep.prototype.startY;
    /** @type {?} */
    SmoothScrollStep.prototype.x;
    /** @type {?} */
    SmoothScrollStep.prototype.y;
    /** @type {?} */
    SmoothScrollStep.prototype.duration;
    /** @type {?} */
    SmoothScrollStep.prototype.easing;
    /** @type {?|undefined} */
    SmoothScrollStep.prototype.currentX;
    /** @type {?|undefined} */
    SmoothScrollStep.prototype.currentY;
}
/**
 * @record
 */
function BezierEasingOptions() { }
if (false) {
    /** @type {?} */
    BezierEasingOptions.prototype.x1;
    /** @type {?} */
    BezierEasingOptions.prototype.y1;
    /** @type {?} */
    BezierEasingOptions.prototype.x2;
    /** @type {?} */
    BezierEasingOptions.prototype.y2;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class SmoothScrollManager {
    /**
     * @param {?} _zone
     * @param {?} _dir
     * @param {?} _document
     * @param {?} _platform
     * @param {?} customDefaultOptions
     */
    constructor(_zone, _dir, _document, _platform, customDefaultOptions) {
        this._zone = _zone;
        this._dir = _dir;
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = Object.assign({ duration: 468, easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            } }, customDefaultOptions);
    }
    /**
     * @private
     * @return {?}
     */
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     * @private
     * @return {?}
     */
    get _now() {
        return this._w.performance && this._w.performance.now
            ? this._w.performance.now.bind(this._w.performance)
            : Date.now;
    }
    /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    _step(context) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            /** @type {?} */
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            /** @type {?} */
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule((/**
             * @return {?}
             */
            () => observer.next(context)));
        }));
    }
    /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        /** @type {?} */
        const destroyed = this._initSmoothScroll(el);
        /** @type {?} */
        const easingOptions = options.easing || this._defaultOptions.easing;
        /** @type {?} */
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration || this._defaultOptions.duration,
            easing: BezierEasing(easingOptions.x1, easingOptions.y1, easingOptions.x2, easingOptions.y2)
        };
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        resolve => {
            // Scroll each step recursively
            of(null).pipe(expand((/**
             * @return {?}
             */
            () => this._step(context).pipe(takeWhile((/**
             * @param {?} currContext
             * @return {?}
             */
            (currContext) => this._isFinished(currContext, destroyed, resolve)))))), takeUntil(this._interrupted(el, destroyed)), finalize((/**
             * @return {?}
             */
            () => this._destroy(el, destroyed)))).subscribe();
        }));
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} options specified the offsets to scroll to.
     * @return {?}
     */
    scrollTo(scrollable, options) {
        if (isPlatformBrowser(this._platform)) {
            /** @type {?} */
            const el = this._getElement(scrollable);
            /** @type {?} */
            const isRtl = getComputedStyle(el).direction === 'rtl';
            /** @type {?} */
            const rtlScrollAxisType = getRtlScrollAxisType();
            // Rewrite start & end offsets as right or left offsets.
            options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;
            options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                ((/** @type {?} */ (options))).top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
                if (options.left != null) {
                    ((/** @type {?} */ (options))).right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    ((/** @type {?} */ (options))).left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
    }
    /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    scrollToElement(scrollable, target, options) {
        /** @type {?} */
        const scrollableEl = this._getElement(scrollable);
        /** @type {?} */
        const targetEl = this._getElement(target, scrollableEl);
        /** @type {?} */
        const duration = options.duration;
        /** @type {?} */
        const easing = options.easing;
        return targetEl ? this.scrollTo(scrollableEl, {
            left: targetEl.offsetLeft + (options.left || 0),
            top: targetEl.offsetTop + (options.top || 0),
            duration,
            easing
        }) : new Promise(null);
    }
}
SmoothScrollManager.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SmoothScrollManager.ctorParameters = () => [
    { type: NgZone },
    { type: Directionality },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
];
/** @nocollapse */ SmoothScrollManager.ngInjectableDef = ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(ɵɵinject(NgZone), ɵɵinject(Directionality), ɵɵinject(DOCUMENT), ɵɵinject(PLATFORM_ID), ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._defaultOptions;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._onGoingScrolls;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._zone;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._document;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._platform;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmoothScroll {
    /**
     * @param {?} element
     * @param {?} smoothScroll
     */
    constructor(element, smoothScroll) {
        this.element = element;
        this.smoothScroll = smoothScroll;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    scrollTo(options) {
        return this.smoothScroll.scrollTo(this.element, options);
    }
    /**
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    scrollToElement(target, options) {
        return this.smoothScroll.scrollToElement(this.element, target, options);
    }
}
SmoothScroll.decorators = [
    { type: Directive, args: [{
                selector: '[smoothScroll], [smooth-scroll]',
                exportAs: 'smoothScroll'
            },] }
];
/** @nocollapse */
SmoothScroll.ctorParameters = () => [
    { type: ElementRef },
    { type: SmoothScrollManager }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmoothScroll.prototype.element;
    /**
     * @type {?}
     * @private
     */
    SmoothScroll.prototype.smoothScroll;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmoothScrollModule {
}
SmoothScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SmoothScroll],
                exports: [SmoothScroll]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };
//# sourceMappingURL=ngx-scrollbar-smooth-scroll.js.map
