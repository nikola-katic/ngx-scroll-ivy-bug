import { Input, Optional, NgZone, Directive, Output, NgModule } from '@angular/core';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { NgScrollbar, NgScrollbarModule } from 'ngx-scrollbar';
import { RtlScrollAxisType } from '@angular/cdk/platform';
import { Subject, Subscription, Observable } from 'rxjs';
import { tap, map, distinctUntilChanged, filter } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
class ReachedFunctions {
    /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    /**
     * @param {?} offset
     * @param {?} e
     * @return {?}
     */
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    /**
     * @param {?} offset
     * @param {?} e
     * @param {?} direction
     * @param {?} rtlScrollAxisType
     * @return {?}
     */
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    /**
     * @param {?} currPosition
     * @param {?} targetPosition
     * @param {?} offset
     * @return {?}
     */
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
/**
 * @abstract
 */
class ScrollReached {
    /**
     * @protected
     * @param {?} scrollbar
     * @param {?} zone
     */
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /**
         * offset: Reached offset value in px
         */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /**
         * subscription: Scrolled event subscription, used to unsubscribe from the event on destroy
         */
        this.subscription = Subscription.EMPTY;
        /**
         * A stream used to assign the reached output
         */
        this.reachedEvent = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.scrollReached().subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => Promise.resolve().then((/**
         * @return {?}
         */
        () => this.zone.run((/**
         * @return {?}
         */
        () => observer.next(_)))))))));
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * @protected
     * @return {?}
     */
    scrollReached() {
        // current event
        /** @type {?} */
        let currEvent;
        return this.scrollEvent.pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => currEvent = e)), 
        // Check if it scroll has reached
        map((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.reached(this.offset, e))), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((/**
         * @param {?} reached
         * @return {?}
         */
        (reached) => reached)), 
        // Return scroll event
        map((/**
         * @return {?}
         */
        () => currEvent)));
    }
}
ScrollReached.propDecorators = {
    offset: [{ type: Input, args: ['reachedOffset',] }]
};
if (false) {
    /**
     * offset: Reached offset value in px
     * @type {?}
     */
    ScrollReached.prototype.offset;
    /**
     * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
     *
     * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.scrollEvent;
    /**
     * subscription: Scrolled event subscription, used to unsubscribe from the event on destroy
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.subscription;
    /**
     * A stream used to assign the reached output
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.reachedEvent;
    /**
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    ScrollReached.prototype.zone;
    /**
     * @abstract
     * @protected
     * @param {?} offset
     * @param {?=} e
     * @return {?}
     */
    ScrollReached.prototype.reached = function (offset, e) { };
}
/**
 * @abstract
 */
class VerticalScrollReached extends ScrollReached {
    /**
     * @protected
     * @param {?} scrollbar
     * @param {?} zone
     */
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
}
/** @nocollapse */
VerticalScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollReached.prototype.zone;
}
/**
 * @abstract
 */
class HorizontalScrollReached extends ScrollReached {
    /**
     * @protected
     * @param {?} scrollbar
     * @param {?} zone
     */
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
}
/** @nocollapse */
HorizontalScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollReached.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollReached.prototype.zone;
}
class NgScrollbarReachedTop extends VerticalScrollReached {
    /**
     * @param {?} scrollbar
     * @param {?} zone
     */
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /**
         * Stream that emits when scroll has reached the top
         */
        this.reachedTop = this.reachedEvent;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
}
NgScrollbarReachedTop.decorators = [
    { type: Directive, args: [{
                selector: '[reachedTop], [reached-top]',
            },] }
];
/** @nocollapse */
NgScrollbarReachedTop.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
NgScrollbarReachedTop.propDecorators = {
    reachedTop: [{ type: Output }]
};
if (false) {
    /**
     * Stream that emits when scroll has reached the top
     * @type {?}
     */
    NgScrollbarReachedTop.prototype.reachedTop;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedTop.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedTop.prototype.zone;
}
class NgScrollbarReachedBottom extends VerticalScrollReached {
    /**
     * @param {?} scrollbar
     * @param {?} zone
     */
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /**
         * Stream that emits when scroll has reached the bottom
         */
        this.reachedBottom = this.reachedEvent;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
}
NgScrollbarReachedBottom.decorators = [
    { type: Directive, args: [{
                selector: '[reachedBottom], [reached-bottom]',
            },] }
];
/** @nocollapse */
NgScrollbarReachedBottom.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
NgScrollbarReachedBottom.propDecorators = {
    reachedBottom: [{ type: Output }]
};
if (false) {
    /**
     * Stream that emits when scroll has reached the bottom
     * @type {?}
     */
    NgScrollbarReachedBottom.prototype.reachedBottom;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedBottom.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedBottom.prototype.zone;
}
class NgScrollbarReachedStart extends HorizontalScrollReached {
    /**
     * @param {?} scrollbar
     * @param {?} zone
     * @param {?} dir
     */
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /**
         * Stream that emits when scroll has reached the start
         */
        this.reachedStart = this.reachedEvent;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedStart.decorators = [
    { type: Directive, args: [{
                selector: '[reachedStart], [reached-start]',
            },] }
];
/** @nocollapse */
NgScrollbarReachedStart.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
NgScrollbarReachedStart.propDecorators = {
    reachedStart: [{ type: Output }]
};
if (false) {
    /**
     * Stream that emits when scroll has reached the start
     * @type {?}
     */
    NgScrollbarReachedStart.prototype.reachedStart;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedStart.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedStart.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbarReachedStart.prototype.dir;
}
class NgScrollbarReachedEnd extends HorizontalScrollReached {
    /**
     * @param {?} scrollbar
     * @param {?} zone
     * @param {?} dir
     */
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /**
         * Stream that emits when scroll has reached the end
         */
        this.reachedEnd = this.reachedEvent;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @protected
     * @param {?} offset Scroll offset
     * @param {?} e Scroll event
     * @return {?}
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedEnd.decorators = [
    { type: Directive, args: [{
                selector: '[reachedEnd], [reached-end]',
            },] }
];
/** @nocollapse */
NgScrollbarReachedEnd.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
NgScrollbarReachedEnd.propDecorators = {
    reachedEnd: [{ type: Output }]
};
if (false) {
    /**
     * Stream that emits when scroll has reached the end
     * @type {?}
     */
    NgScrollbarReachedEnd.prototype.reachedEnd;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedEnd.prototype.scrollbar;
    /**
     * @type {?}
     * @protected
     */
    NgScrollbarReachedEnd.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbarReachedEnd.prototype.dir;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarReachedModule {
}
NgScrollbarReachedModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    NgScrollbarModule,
                    BidiModule
                ],
                declarations: [
                    NgScrollbarReachedTop,
                    NgScrollbarReachedBottom,
                    NgScrollbarReachedStart,
                    NgScrollbarReachedEnd
                ],
                exports: [
                    NgScrollbarReachedTop,
                    NgScrollbarReachedBottom,
                    NgScrollbarReachedStart,
                    NgScrollbarReachedEnd
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgScrollbarReachedBottom, NgScrollbarReachedEnd, NgScrollbarReachedModule, NgScrollbarReachedStart, NgScrollbarReachedTop };
//# sourceMappingURL=ngx-scrollbar-reached-event.js.map
