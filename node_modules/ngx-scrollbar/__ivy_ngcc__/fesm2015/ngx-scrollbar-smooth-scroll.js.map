{"version":3,"sources":["/home/nikola/Documents/Repos/ivy-bug/ngx-scroll-ivy-bug/ngx-scrollbar-bug/node_modules/ngx-scrollbar/fesm2015/ngx-scrollbar-smooth-scroll.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4TC,+UAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuED,6KAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwBD,2JAMC","file":"ngx-scrollbar-smooth-scroll.js","sourcesContent":["import { InjectionToken, Injectable, NgZone, Inject, PLATFORM_ID, Optional, ɵɵdefineInjectable, ɵɵinject, Directive, ElementRef, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\r\n/**\r\n * @record\r\n */\r\nfunction SmoothScrollOptions() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    SmoothScrollOptions.prototype.duration;\r\n    /** @type {?|undefined} */\r\n    SmoothScrollOptions.prototype.easing;\r\n}\r\n/**\r\n * @record\r\n */\r\nfunction SmoothScrollStep() { }\r\nif (false) {\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.scrollable;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.startTime;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.startX;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.startY;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.x;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.y;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.duration;\r\n    /** @type {?} */\r\n    SmoothScrollStep.prototype.easing;\r\n    /** @type {?|undefined} */\r\n    SmoothScrollStep.prototype.currentX;\r\n    /** @type {?|undefined} */\r\n    SmoothScrollStep.prototype.currentY;\r\n}\r\n/**\r\n * @record\r\n */\r\nfunction BezierEasingOptions() { }\r\nif (false) {\r\n    /** @type {?} */\r\n    BezierEasingOptions.prototype.x1;\r\n    /** @type {?} */\r\n    BezierEasingOptions.prototype.y1;\r\n    /** @type {?} */\r\n    BezierEasingOptions.prototype.x2;\r\n    /** @type {?} */\r\n    BezierEasingOptions.prototype.y2;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// @dynamic\r\nclass SmoothScrollManager {\r\n    /**\r\n     * @param {?} _zone\r\n     * @param {?} _dir\r\n     * @param {?} _document\r\n     * @param {?} _platform\r\n     * @param {?} customDefaultOptions\r\n     */\r\n    constructor(_zone, _dir, _document, _platform, customDefaultOptions) {\r\n        this._zone = _zone;\r\n        this._dir = _dir;\r\n        this._document = _document;\r\n        this._platform = _platform;\r\n        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\r\n        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\r\n        // Purpose: If user called a scroll function again on the same element before the scrolls completes,\r\n        // it cancels the ongoing scroll and starts a new one\r\n        this._onGoingScrolls = new Map();\r\n        this._defaultOptions = Object.assign({ duration: 468, easing: {\r\n                x1: 0.42,\r\n                y1: 0,\r\n                x2: 0.58,\r\n                y2: 1\r\n            } }, customDefaultOptions);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    get _w() {\r\n        return this._document.defaultView;\r\n    }\r\n    /**\r\n     * Timing method\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    get _now() {\r\n        return this._w.performance && this._w.performance.now\r\n            ? this._w.performance.now.bind(this._w.performance)\r\n            : Date.now;\r\n    }\r\n    /**\r\n     * changes scroll position inside an element\r\n     * @private\r\n     * @param {?} el\r\n     * @param {?} x\r\n     * @param {?} y\r\n     * @return {?}\r\n     */\r\n    _scrollElement(el, x, y) {\r\n        el.scrollLeft = x;\r\n        el.scrollTop = y;\r\n    }\r\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     * @private\r\n     * @param {?} el\r\n     * @param {?=} parent\r\n     * @return {?}\r\n     */\r\n    _getElement(el, parent) {\r\n        if (typeof el === 'string') {\r\n            return (parent || this._document).querySelector(el);\r\n        }\r\n        return coerceElement(el);\r\n    }\r\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     * @private\r\n     * @param {?} el\r\n     * @return {?}\r\n     */\r\n    _initSmoothScroll(el) {\r\n        if (this._onGoingScrolls.has(el)) {\r\n            this._onGoingScrolls.get(el).next();\r\n        }\r\n        return this._onGoingScrolls.set(el, new Subject()).get(el);\r\n    }\r\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     * @private\r\n     * @param {?} context\r\n     * @param {?} destroyed\r\n     * @param {?} resolve\r\n     * @return {?}\r\n     */\r\n    _isFinished(context, destroyed, resolve) {\r\n        if (context.currentX !== context.x || context.currentY !== context.y) {\r\n            return true;\r\n        }\r\n        destroyed.next();\r\n        resolve();\r\n        return false;\r\n    }\r\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     * @private\r\n     * @param {?} el\r\n     * @param {?} destroyed\r\n     * @return {?}\r\n     */\r\n    _interrupted(el, destroyed) {\r\n        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));\r\n    }\r\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     * @private\r\n     * @param {?} el\r\n     * @param {?} destroyed\r\n     * @return {?}\r\n     */\r\n    _destroy(el, destroyed) {\r\n        destroyed.complete();\r\n        this._onGoingScrolls.delete(el);\r\n    }\r\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     * @private\r\n     * @param {?} context\r\n     * @return {?}\r\n     */\r\n    _step(context) {\r\n        return new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        observer => {\r\n            /** @type {?} */\r\n            let elapsed = (this._now() - context.startTime) / context.duration;\r\n            // avoid elapsed times higher than one\r\n            elapsed = elapsed > 1 ? 1 : elapsed;\r\n            // apply easing to elapsed time\r\n            /** @type {?} */\r\n            const value = context.easing(elapsed);\r\n            context.currentX = context.startX + (context.x - context.startX) * value;\r\n            context.currentY = context.startY + (context.y - context.startY) * value;\r\n            this._scrollElement(context.scrollable, context.currentX, context.currentY);\r\n            // Proceed to the step\r\n            animationFrameScheduler.schedule((/**\r\n             * @return {?}\r\n             */\r\n            () => observer.next(context)));\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} el\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    _applyScrollToOptions(el, options) {\r\n        if (!options.duration) {\r\n            this._scrollElement(el, options.left, options.top);\r\n            return Promise.resolve();\r\n        }\r\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\r\n        /** @type {?} */\r\n        const destroyed = this._initSmoothScroll(el);\r\n        /** @type {?} */\r\n        const easingOptions = options.easing || this._defaultOptions.easing;\r\n        /** @type {?} */\r\n        const context = {\r\n            scrollable: el,\r\n            startTime: this._now(),\r\n            startX: el.scrollLeft,\r\n            startY: el.scrollTop,\r\n            x: options.left == null ? el.scrollLeft : ~~options.left,\r\n            y: options.top == null ? el.scrollTop : ~~options.top,\r\n            duration: options.duration || this._defaultOptions.duration,\r\n            easing: BezierEasing(easingOptions.x1, easingOptions.y1, easingOptions.x2, easingOptions.y2)\r\n        };\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        resolve => {\r\n            // Scroll each step recursively\r\n            of(null).pipe(expand((/**\r\n             * @return {?}\r\n             */\r\n            () => this._step(context).pipe(takeWhile((/**\r\n             * @param {?} currContext\r\n             * @return {?}\r\n             */\r\n            (currContext) => this._isFinished(currContext, destroyed, resolve)))))), takeUntil(this._interrupted(el, destroyed)), finalize((/**\r\n             * @return {?}\r\n             */\r\n            () => this._destroy(el, destroyed)))).subscribe();\r\n        }));\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param {?} scrollable element\r\n     * @param {?} options specified the offsets to scroll to.\r\n     * @return {?}\r\n     */\r\n    scrollTo(scrollable, options) {\r\n        if (isPlatformBrowser(this._platform)) {\r\n            /** @type {?} */\r\n            const el = this._getElement(scrollable);\r\n            /** @type {?} */\r\n            const isRtl = getComputedStyle(el).direction === 'rtl';\r\n            /** @type {?} */\r\n            const rtlScrollAxisType = getRtlScrollAxisType();\r\n            // Rewrite start & end offsets as right or left offsets.\r\n            options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;\r\n            options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;\r\n            // Rewrite the bottom offset as a top offset.\r\n            if (options.bottom != null) {\r\n                ((/** @type {?} */ (options))).top = el.scrollHeight - el.clientHeight - options.bottom;\r\n            }\r\n            // Rewrite the right offset as a left offset.\r\n            if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {\r\n                if (options.left != null) {\r\n                    ((/** @type {?} */ (options))).right = el.scrollWidth - el.clientWidth - options.left;\r\n                }\r\n                if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {\r\n                    options.left = options.right;\r\n                }\r\n                else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {\r\n                    options.left = options.right ? -options.right : options.right;\r\n                }\r\n            }\r\n            else {\r\n                if (options.right != null) {\r\n                    ((/** @type {?} */ (options))).left = el.scrollWidth - el.clientWidth - options.right;\r\n                }\r\n            }\r\n            return this._applyScrollToOptions(el, options);\r\n        }\r\n    }\r\n    /**\r\n     * Scroll to element by reference or selector\r\n     * @param {?} scrollable\r\n     * @param {?} target\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    scrollToElement(scrollable, target, options) {\r\n        /** @type {?} */\r\n        const scrollableEl = this._getElement(scrollable);\r\n        /** @type {?} */\r\n        const targetEl = this._getElement(target, scrollableEl);\r\n        /** @type {?} */\r\n        const duration = options.duration;\r\n        /** @type {?} */\r\n        const easing = options.easing;\r\n        return targetEl ? this.scrollTo(scrollableEl, {\r\n            left: targetEl.offsetLeft + (options.left || 0),\r\n            top: targetEl.offsetTop + (options.top || 0),\r\n            duration,\r\n            easing\r\n        }) : new Promise(null);\r\n    }\r\n}\r\nSmoothScrollManager.decorators = [\r\n    { type: Injectable, args: [{\r\n                providedIn: 'root'\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nSmoothScrollManager.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: Directionality },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }\r\n];\r\n/** @nocollapse */ SmoothScrollManager.ngInjectableDef = ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(ɵɵinject(NgZone), ɵɵinject(Directionality), ɵɵinject(DOCUMENT), ɵɵinject(PLATFORM_ID), ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: \"root\" });\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScrollManager.prototype._defaultOptions;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScrollManager.prototype._onGoingScrolls;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScrollManager.prototype._zone;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScrollManager.prototype._dir;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScrollManager.prototype._document;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScrollManager.prototype._platform;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass SmoothScroll {\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} smoothScroll\r\n     */\r\n    constructor(element, smoothScroll) {\r\n        this.element = element;\r\n        this.smoothScroll = smoothScroll;\r\n    }\r\n    /**\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    scrollTo(options) {\r\n        return this.smoothScroll.scrollTo(this.element, options);\r\n    }\r\n    /**\r\n     * @param {?} target\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    scrollToElement(target, options) {\r\n        return this.smoothScroll.scrollToElement(this.element, target, options);\r\n    }\r\n}\r\nSmoothScroll.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[smoothScroll], [smooth-scroll]',\r\n                exportAs: 'smoothScroll'\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nSmoothScroll.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: SmoothScrollManager }\r\n];\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScroll.prototype.element;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SmoothScroll.prototype.smoothScroll;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass SmoothScrollModule {\r\n}\r\nSmoothScrollModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                declarations: [SmoothScroll],\r\n                exports: [SmoothScroll]\r\n            },] }\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };\n"]}