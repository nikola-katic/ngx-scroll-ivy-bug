import { Directive, ElementRef, InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, ChangeDetectionStrategy, NgZone, ChangeDetectorRef, ViewChild, ContentChild, Input, Output, Pipe, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { PortalModule } from '@angular/cdk/portal';
import { getRtlScrollAxisType, Platform, RtlScrollAxisType, PlatformModule } from '@angular/cdk/platform';
import { SmoothScrollManager, SmoothScrollModule } from 'ngx-scrollbar/smooth-scroll';
import { of, BehaviorSubject, fromEvent, Subject, Observable, EMPTY, merge, asyncScheduler, animationFrameScheduler, from } from 'rxjs';
import { tap, switchMap, debounceTime, pluck, pairwise, filter, map, takeUntil, distinctUntilChanged, mergeMap, catchError } from 'rxjs/operators';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["viewport"];
const _c1 = [1, "ng-scrollbar-wrapper", 3, "ngAttr"];
const _c2 = ["resizeSensor", "", 1, "ng-scroll-viewport-wrapper", 3, "sensorDebounce", "sensorDisabled"];
const _c3 = [3, "ngClass"];
const _c4 = ["viewport", ""];
const _c5 = [4, "ngIf"];
const _c6 = ["track", "vertical", 4, "ngIf"];
const _c7 = ["track", "horizontal", 4, "ngIf"];
const _c8 = ["track", "vertical"];
function NgScrollbar_ng_container_8_scrollbar_control_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "scrollbar-control", _c8);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("scrollable", ctx_r2.state.isVerticallyScrollable)("fit", ctx_r2.state.horizontalUsed);
} }
const _c9 = ["track", "horizontal"];
function NgScrollbar_ng_container_8_scrollbar_control_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "scrollbar-control", _c9);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("scrollable", ctx_r3.state.isHorizontallyScrollable)("fit", ctx_r3.state.verticalUsed);
} }
function NgScrollbar_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NgScrollbar_ng_container_8_scrollbar_control_1_Template, 1, 2, "scrollbar-control", _c6);
    ɵngcc0.ɵɵtemplate(2, NgScrollbar_ng_container_8_scrollbar_control_2_Template, 1, 2, "scrollbar-control", _c7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.state.verticalUsed);
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.state.horizontalUsed);
} }
const _c10 = ["*"];
const _c11 = ["track"];
const _c12 = ["thumb"];
const _c13 = ["track", ""];
const _c14 = ["thumb", ""];
class ScrollViewport {
    /**
     * @param {?} viewPort
     */
    constructor(viewPort) {
        this.viewPort = viewPort;
    }
}
ScrollViewport.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: ScrollViewport, selectors: [["", "scrollViewport", ""], ["", "scroll-viewport", ""]], factory: function ScrollViewport_Factory(t) { return new (t || ScrollViewport)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, hostBindings: function ScrollViewport_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ng-scroll-viewport", true);
        ɵngcc0.ɵɵstylingApply();
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ScrollViewport, [{
        type: Directive,
        args: [{
                selector: '[scrollViewport], [scroll-viewport]',
                host: {
                    '[class.ng-scroll-viewport]': 'true'
                }
            }]
    }], function () { return [{ type: ElementRef }]; }, { constructor: [], viewPort: [] });
/** @nocollapse */
ScrollViewport.ctorParameters = () => [
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    ScrollViewport.prototype.viewPort;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');
/**
 * @record
 */
function NgScrollbarOptions() { }
if (false) {
    /**
     * Sets the scroll axis of the viewport, there are 3 options:
     *
     * - `vertical` Use both vertical and horizontal scrollbar-control
     * - `horizontal` Use both vertical and horizontal scrollbar-control
     * - `all` Use both vertical and horizontal scrollbar-control
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.track;
    /**
     * When to show the scrollbar, and there are 3 options:
     *
     * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar-control
     * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
     * - `always` Scrollbars are always shown even if the viewport is not scrollable
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.visibility;
    /**
     *  Sets the appearance of the scrollbar, there are 2 options:
     *
     * - `standard` (default) scrollbar space will be reserved just like with native scrollbar-control.
     * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.appearance;
    /**
     * Sets the position of each scrollbar, there are 4 options:
     *
     * - `native` (Default) Use the default position like in native scrollbar-control.
     * - `invertY` Inverts vertical scrollbar position
     * - `invertX` Inverts Horizontal scrollbar position
     * - `invertAll` Inverts both scrollbar-control positions
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.position;
    /**
     * A class forwarded to scrollable viewport element
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.viewClass;
    /**
     * A class forwarded to the scrollbar track element
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.trackClass;
    /**
     * A class forwarded to the scrollbar thumb element
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.thumbClass;
    /**
     * The minimum scrollbar thumb size in px
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.minThumbSize;
    /**
     * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.trackClickScrollDuration;
    /**
     * A flag used to enable/disable the scrollbar track clicked event
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.trackClickDisabled;
    /**
     * A flag used to enable/disable the scrollbar thumb dragged event
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.thumbDragDisabled;
    /**
     * Debounce interval for detecting changes via window.resize event
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.windowResizeDebounce;
    /**
     * Debounce interval for detecting changes via ResizeObserver
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.sensorDebounce;
    /**
     * Whether ResizeObserver is disabled
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.sensorDisabled;
}
/**
 * Set of attributes added on the scrollbar wrapper
 * @record
 */
function NgScrollbarState() { }
if (false) {
    /** @type {?|undefined} */
    NgScrollbarState.prototype.position;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.track;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.appearance;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.visibility;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.disabled;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.dir;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.verticalUsed;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.horizontalUsed;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.isVerticallyScrollable;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.isHorizontallyScrollable;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.verticalHovered;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.horizontalHovered;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.verticalDragging;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.horizontalDragging;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOptions = {
    viewClass: '',
    trackClass: '',
    thumbClass: '',
    track: 'vertical',
    appearance: 'compact',
    visibility: 'native',
    position: 'native',
    thumbDragDisabled: false,
    trackClickDisabled: false,
    trackClickScrollDuration: 300,
    minThumbSize: 20,
    windowResizeDebounce: 0,
    sensorDebounce: 0,
    sensorDisabled: false
};
class ScrollbarManager {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.globalOptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;
        this.rtlScrollAxisType = getRtlScrollAxisType();
    }
}
ScrollbarManager.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: ScrollbarManager, factory: function ScrollbarManager_Factory(t) { return new (t || ScrollbarManager)(ɵngcc0.ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, providedIn: 'root' });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ScrollbarManager, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NG_SCROLLBAR_OPTIONS]
            }] }]; }, { constructor: [], globalOptions: [], rtlScrollAxisType: [] });
/** @nocollapse */
ScrollbarManager.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }
];
/** @nocollapse */ ScrollbarManager.ngInjectableDef = ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: "root" });
if (false) {
    /** @type {?} */
    ScrollbarManager.prototype.globalOptions;
    /** @type {?} */
    ScrollbarManager.prototype.rtlScrollAxisType;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NativeScrollbarSizeFactory {
    /**
     * @param {?} document
     * @param {?} manager
     * @param {?} platform
     */
    constructor(document, manager, platform) {
        this.document = document;
        this.manager = manager;
        this.platform = platform;
        if (platform.isBrowser) {
            of(null).pipe(tap((/**
             * @return {?}
             */
            () => this._nativeScrollbarSize = new BehaviorSubject(this.getNativeScrollbarSize()))), tap((/**
             * @return {?}
             */
            () => this.nativeScrollbarSize = this._nativeScrollbarSize.asObservable())), switchMap((/**
             * @return {?}
             */
            () => fromEvent(this.document.defaultView, 'resize', { passive: true }))), debounceTime(this.manager.globalOptions.windowResizeDebounce), tap((/**
             * @return {?}
             */
            () => this._nativeScrollbarSize.next(this.getNativeScrollbarSize())))).subscribe();
        }
    }
    /**
     * Get native scrollbar size
     * @private
     * @return {?}
     */
    getNativeScrollbarSize() {
        if (this.platform.ANDROID || this.platform.IOS) {
            return 6;
        }
        /** @type {?} */
        const box = this.document.createElement('div');
        box.className = 'ng-scrollbar-measure';
        this.document.body.appendChild(box);
        /** @type {?} */
        const size = box.getBoundingClientRect().right;
        this.document.body.removeChild(box);
        // if size is 0, return 15 (for MAC OS browsers)
        return size || 15;
    }
}
NativeScrollbarSizeFactory.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NativeScrollbarSizeFactory, factory: function NativeScrollbarSizeFactory_Factory(t) { return new (t || NativeScrollbarSizeFactory)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ScrollbarManager), ɵngcc0.ɵɵinject(Platform)); }, providedIn: 'root' });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NativeScrollbarSizeFactory, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ScrollbarManager }, { type: Platform }]; }, { constructor: [], document: [], manager: [], platform: [], _nativeScrollbarSize: [], nativeScrollbarSize: [], getNativeScrollbarSize: [] });
/** @nocollapse */
NativeScrollbarSizeFactory.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ScrollbarManager },
    { type: Platform }
];
/** @nocollapse */ NativeScrollbarSizeFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(ɵɵinject(DOCUMENT), ɵɵinject(ScrollbarManager), ɵɵinject(Platform)); }, token: NativeScrollbarSizeFactory, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype._nativeScrollbarSize;
    /** @type {?} */
    NativeScrollbarSizeFactory.prototype.nativeScrollbarSize;
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype.document;
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype.manager;
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype.platform;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbar {
    /**
     * @param {?} el
     * @param {?} zone
     * @param {?} changeDetectorRef
     * @param {?} dir
     * @param {?} smoothScroll
     * @param {?} manager
     * @param {?} nativeScrollbarSizeFactory
     */
    constructor(el, zone, changeDetectorRef, dir, smoothScroll, manager, nativeScrollbarSizeFactory) {
        this.el = el;
        this.zone = zone;
        this.changeDetectorRef = changeDetectorRef;
        this.dir = dir;
        this.smoothScroll = smoothScroll;
        this.manager = manager;
        this.nativeScrollbarSizeFactory = nativeScrollbarSizeFactory;
        /**
         * A class forwarded to scrollable viewport element
         */
        this.viewClass = this.manager.globalOptions.viewClass;
        /**
         * A class forwarded to the scrollbar track element
         */
        this.trackClass = this.manager.globalOptions.trackClass;
        /**
         * A class forwarded to the scrollbar thumb element
         */
        this.thumbClass = this.manager.globalOptions.thumbClass;
        /**
         * Minimum scrollbar thumb size
         */
        this.minThumbSize = this.manager.globalOptions.minThumbSize;
        /**
         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
         */
        this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;
        /**
         * A flag used to enable/disable the scrollbar track clicked event
         */
        this.trackClickDisabled = this.manager.globalOptions.trackClickDisabled;
        /**
         * A flag used to enable/disable the scrollbar thumb dragged event
         */
        this.thumbDragDisabled = this.manager.globalOptions.thumbDragDisabled;
        /**
         * Disable custom scrollbar and switch back to native scrollbar
         */
        this.disabled = false;
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `all` Use both vertical and horizontal scrollbar
         */
        this.track = this.manager.globalOptions.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         */
        this.visibility = this.manager.globalOptions.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         */
        this.appearance = this.manager.globalOptions.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         */
        this.position = this.manager.globalOptions.position;
        /**
         * Debounce interval for detecting changes via ResizeObserver
         */
        this.sensorDebounce = this.manager.globalOptions.sensorDebounce;
        /**
         * Whether ResizeObserver is disabled
         */
        this.sensorDisabled = this.manager.globalOptions.sensorDisabled;
        /**
         * Steam that emits when scrollbar is updated
         */
        this.updated = new EventEmitter();
        /**
         * Set of attributes added on the scrollbar wrapper
         */
        this.state = {};
        /**
         * Stream that destroys components' observables
         */
        this.destroyed = new Subject();
    }
    /**
     * @private
     * @param {?} track
     * @return {?}
     */
    getScrolledByDirection(track) {
        /** @type {?} */
        const scrollProperty = track === 'vertical' ? 'scrollTop' : 'scrollLeft';
        /** @type {?} */
        let event;
        return this.scrolled.pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => event = e)), pluck('target', scrollProperty), pairwise(), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([prev, curr]) => prev !== curr)), map((/**
         * @return {?}
         */
        () => event)));
    }
    /**
     * Update local state with each change detection
     * @private
     * @return {?}
     */
    updateState() {
        /** @type {?} */
        let verticalUsed = false;
        /** @type {?} */
        let horizontalUsed = false;
        /** @type {?} */
        let isVerticallyScrollable = false;
        /** @type {?} */
        let isHorizontallyScrollable = false;
        // Check if vertical scrollbar should be displayed
        if (this.track === 'all' || this.track === 'vertical') {
            isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;
            verticalUsed = this.visibility === 'always' || isVerticallyScrollable;
        }
        // Check if horizontal scrollbar should be displayed
        if (this.track === 'all' || this.track === 'horizontal') {
            isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;
            horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;
        }
        this._updateState({
            position: this.position,
            track: this.track,
            appearance: this.appearance,
            visibility: this.visibility,
            disabled: this.disabled,
            dir: this.dir.value,
            verticalUsed,
            horizontalUsed,
            isVerticallyScrollable,
            isHorizontallyScrollable
        });
    }
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    _updateState(state) {
        this.state = Object.assign({}, this.state, state);
        this.changeDetectorRef.detectChanges();
    }
    /**
     * @param {?} hovered
     * @return {?}
     */
    setHovered(hovered) {
        this.zone.run((/**
         * @return {?}
         */
        () => this._updateState(Object.assign({}, hovered))));
    }
    /**
     * @param {?} dragging
     * @return {?}
     */
    setDragging(dragging) {
        this.zone.run((/**
         * @return {?}
         */
        () => this._updateState(Object.assign({}, dragging))));
    }
    /**
     * Set the viewport based on user choice
     * @private
     * @return {?}
     */
    setViewport() {
        if (this.customViewPort) {
            // Set the custom viewport as the scroll viewport
            this.viewport = this.customViewPort.viewPort.nativeElement;
            // In this case the default viewport and the default content wrapper will act as a mask
            this.viewportClasses = {
                'ng-scroll-offset': true,
                'ng-scroll-layer': true
            };
            this.defaultViewPort.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
        else {
            // Set the default viewport as the scroll viewport
            this.viewport = this.defaultViewPort.nativeElement;
            this.viewportClasses = {
                'ng-scroll-offset': true,
                'ng-scroll-viewport': true,
                [this.viewClass]: true,
            };
        }
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.viewport.firstElementChild) {
            this.contentWrapper = (/** @type {?} */ (this.viewport.firstElementChild));
            this.contentWrapper.classList.add('ng-scroll-content');
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.setViewport();
            // Initialize scroll streams
            this.scrolled = new Observable((/**
             * @param {?} observer
             * @return {?}
             */
            (observer) => fromEvent(this.viewport, 'scroll', { passive: true }).pipe(takeUntil(this.destroyed))
                .subscribe(observer)));
            this.verticalScrolled = this.getScrolledByDirection('vertical');
            this.horizontalScrolled = this.getScrolledByDirection('horizontal');
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.updateState();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed.next();
        this.destroyed.complete();
    }
    /**
     * Update local state and the internal scrollbar controls
     * @return {?}
     */
    update() {
        this.updated.next();
        this.changeDetectorRef.detectChanges();
    }
    /**
     * Smooth scroll functions
     * @param {?} options
     * @return {?}
     */
    scrollTo(options) {
        return this.smoothScroll.scrollTo(this.viewport, options);
    }
    /**
     * Scroll to element by reference or selector
     * @param {?} target
     * @param {?=} options
     * @return {?}
     */
    scrollToElement(target, options) {
        return this.smoothScroll.scrollToElement(this.viewport, target, options);
    }
}
NgScrollbar.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgScrollbar, selectors: [["ng-scrollbar"]], factory: function NgScrollbar_Factory(t) { return new (t || NgScrollbar)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Directionality), ɵngcc0.ɵɵdirectiveInject(SmoothScrollManager), ɵngcc0.ɵɵdirectiveInject(ScrollbarManager), ɵngcc0.ɵɵdirectiveInject(NativeScrollbarSizeFactory)); }, contentQueries: function NgScrollbar_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ScrollViewport, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.customViewPort = _t.first);
    } }, viewQuery: function NgScrollbar_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.defaultViewPort = _t.first);
    } }, hostBindings: function NgScrollbar_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ng-scrollbar", true);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { viewClass: "viewClass", trackClass: "trackClass", thumbClass: "thumbClass", minThumbSize: "minThumbSize", trackClickScrollDuration: "trackClickScrollDuration", trackClickDisabled: "trackClickDisabled", thumbDragDisabled: "thumbDragDisabled", disabled: "disabled", track: "track", visibility: "visibility", appearance: "appearance", position: "position", sensorDebounce: "sensorDebounce", sensorDisabled: "sensorDisabled" }, outputs: { updated: "updated" }, exportAs: ["ngScrollbar"], ngContentSelectors: _c10, consts: 9, vars: 11, template: function NgScrollbar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", _c1);
        ɵngcc0.ɵɵelementStart(1, "div", _c2);
        ɵngcc0.ɵɵelementStart(2, "div", _c3, _c4);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵpipe(4, "cssVariable");
        ɵngcc0.ɵɵpipe(5, "async");
        ɵngcc0.ɵɵelementStart(6, "div");
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, NgScrollbar_ng_container_8_Template, 3, 2, "ng-container", _c5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngAttr", ctx.state);
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵproperty("sensorDebounce", ctx.sensorDebounce)("sensorDisabled", ctx.sensorDisabled);
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵstyleSanitizer(ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵstyleMap(ɵngcc0.ɵɵpipeBind2(4, 6, ɵngcc0.ɵɵpipeBind1(5, 9, ctx.nativeScrollbarSizeFactory.nativeScrollbarSize), "native-scrollbar-size"));
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("ngClass", ctx.viewportClasses);
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disabled);
    } }, directives: function () { return [NgAttr,
        ResizeSensor, ɵngcc1.NgClass, ɵngcc1.NgIf, ScrollbarControl]; }, pipes: function () { return [CssVariable, ɵngcc1.AsyncPipe]; }, styles: [".ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px}[_nghost-%COMP%]{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);display:block;position:relative;height:100%}[_nghost-%COMP%] > .ng-scrollbar-wrapper[_ngcontent-%COMP%]{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalDragging=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalHovered=true][_ngcontent-%COMP%]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalDragging=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalHovered=true][_ngcontent-%COMP%]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-top:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-offset[_ngcontent-%COMP%]{bottom:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-offset[_ngcontent-%COMP%]{left:0;right:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-offset[_ngcontent-%COMP%]{right:0;left:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][visibility=hover][_ngcontent-%COMP%] > .scrollbar-control[_ngcontent-%COMP%]{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}[_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][visibility=hover][_ngcontent-%COMP%]:active > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][visibility=hover][_ngcontent-%COMP%]:focus > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[disabled=false][visibility=hover][_ngcontent-%COMP%]:hover > .scrollbar-control[_ngcontent-%COMP%]{opacity:1;transition-duration:.4s;transition-delay:0s}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{overflow-x:auto;overflow-y:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{overflow:auto}.ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{overflow:hidden}.ng-scroll-viewport[_ngcontent-%COMP%]{-ms-scroll-chaining:contain contain;overscroll-behavior:contain contain;-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}  .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer[_ngcontent-%COMP%], .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], .ng-scrollbar-wrapper[_ngcontent-%COMP%],   .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}"], changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgScrollbar, [{
        type: Component,
        args: [{
                selector: 'ng-scrollbar',
                exportAs: 'ngScrollbar',
                template: "<div class=\"ng-scrollbar-wrapper\" [ngAttr]=\"state\">\r\n  <div class=\"ng-scroll-viewport-wrapper\"\r\n       resizeSensor\r\n       [sensorDebounce]=\"sensorDebounce\"\r\n       [sensorDisabled]=\"sensorDisabled\">\r\n    <div #viewport\r\n         [ngClass]=\"viewportClasses\"\r\n         [style]=\"nativeScrollbarSizeFactory.nativeScrollbarSize | async | cssVariable: 'native-scrollbar-size'\">\r\n      <div>\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <ng-container *ngIf=\"!disabled\">\r\n    <scrollbar-control *ngIf=\"state.verticalUsed\"\r\n                       track=\"vertical\"\r\n                       [attr.scrollable]=\"state.isVerticallyScrollable\"\r\n                       [attr.fit]=\"state.horizontalUsed\">\r\n    </scrollbar-control>\r\n    <scrollbar-control *ngIf=\"state.horizontalUsed\"\r\n                       track=\"horizontal\"\r\n                       [attr.scrollable]=\"state.isHorizontallyScrollable\"\r\n                       [attr.fit]=\"state.verticalUsed\">\r\n    </scrollbar-control>\r\n  </ng-container>\r\n</div>\r\n\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { '[class.ng-scrollbar]': 'true' },
                styles: ["::ng-deep .ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);display:block;position:relative;height:100%}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:.4s;transition-delay:0s}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-ms-scroll-chaining:contain contain;overscroll-behavior:contain contain;-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}"]
            }]
    }], function () { return [{ type: ElementRef }, { type: NgZone }, { type: ChangeDetectorRef }, { type: Directionality }, { type: SmoothScrollManager }, { type: ScrollbarManager }, { type: NativeScrollbarSizeFactory }]; }, { constructor: [], el: [], zone: [], changeDetectorRef: [], dir: [], smoothScroll: [], manager: [], nativeScrollbarSizeFactory: [], viewClass: [{
            type: Input
        }], trackClass: [{
            type: Input
        }], thumbClass: [{
            type: Input
        }], minThumbSize: [{
            type: Input
        }], trackClickScrollDuration: [{
            type: Input
        }], trackClickDisabled: [{
            type: Input
        }], thumbDragDisabled: [{
            type: Input
        }], disabled: [{
            type: Input
        }], track: [{
            type: Input
        }], visibility: [{
            type: Input
        }], appearance: [{
            type: Input
        }], position: [{
            type: Input
        }], sensorDebounce: [{
            type: Input
        }], sensorDisabled: [{
            type: Input
        }], updated: [{
            type: Output
        }], state: [], destroyed: [], getScrolledByDirection: [], updateState: [], _updateState: [], setHovered: [], setDragging: [], setViewport: [], viewport: [], viewportClasses: [], contentWrapper: [], ngOnInit: [], scrolled: [], verticalScrolled: [], horizontalScrolled: [], ngAfterViewChecked: [], ngOnDestroy: [], update: [], scrollTo: [], scrollToElement: [], defaultViewPort: [{
            type: ViewChild,
            args: ['viewport', { static: true }]
        }], customViewPort: [{
            type: ContentChild,
            args: [ScrollViewport, { static: true }]
        }] });
/** @nocollapse */
NgScrollbar.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Directionality },
    { type: SmoothScrollManager },
    { type: ScrollbarManager },
    { type: NativeScrollbarSizeFactory }
];
NgScrollbar.propDecorators = {
    defaultViewPort: [{ type: ViewChild, args: ['viewport', { static: true },] }],
    customViewPort: [{ type: ContentChild, args: [ScrollViewport, { static: true },] }],
    viewClass: [{ type: Input }],
    trackClass: [{ type: Input }],
    thumbClass: [{ type: Input }],
    minThumbSize: [{ type: Input }],
    trackClickScrollDuration: [{ type: Input }],
    trackClickDisabled: [{ type: Input }],
    thumbDragDisabled: [{ type: Input }],
    disabled: [{ type: Input }],
    track: [{ type: Input }],
    visibility: [{ type: Input }],
    appearance: [{ type: Input }],
    position: [{ type: Input }],
    sensorDebounce: [{ type: Input }],
    sensorDisabled: [{ type: Input }],
    updated: [{ type: Output }]
};
if (false) {
    /**
     * Default viewport reference
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.defaultViewPort;
    /**
     * Custom viewport reference
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.customViewPort;
    /**
     * A class forwarded to scrollable viewport element
     * @type {?}
     */
    NgScrollbar.prototype.viewClass;
    /**
     * A class forwarded to the scrollbar track element
     * @type {?}
     */
    NgScrollbar.prototype.trackClass;
    /**
     * A class forwarded to the scrollbar thumb element
     * @type {?}
     */
    NgScrollbar.prototype.thumbClass;
    /**
     * Minimum scrollbar thumb size
     * @type {?}
     */
    NgScrollbar.prototype.minThumbSize;
    /**
     * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
     * @type {?}
     */
    NgScrollbar.prototype.trackClickScrollDuration;
    /**
     * A flag used to enable/disable the scrollbar track clicked event
     * @type {?}
     */
    NgScrollbar.prototype.trackClickDisabled;
    /**
     * A flag used to enable/disable the scrollbar thumb dragged event
     * @type {?}
     */
    NgScrollbar.prototype.thumbDragDisabled;
    /**
     * Disable custom scrollbar and switch back to native scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.disabled;
    /**
     * Sets the supported scroll track of the viewport, there are 3 options:
     *
     * - `vertical` Use both vertical and horizontal scrollbar
     * - `horizontal` Use both vertical and horizontal scrollbar
     * - `all` Use both vertical and horizontal scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.track;
    /**
     * When to show the scrollbar, and there are 3 options:
     *
     * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
     * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
     * - `always` Scrollbars are always shown even if the viewport is not scrollable
     * @type {?}
     */
    NgScrollbar.prototype.visibility;
    /**
     *  Sets the appearance of the scrollbar, there are 2 options:
     *
     * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
     * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
     * @type {?}
     */
    NgScrollbar.prototype.appearance;
    /**
     * Sets the position of each scrollbar, there are 4 options:
     *
     * - `native` (Default) Use the default position like in native scrollbar.
     * - `invertY` Inverts vertical scrollbar position
     * - `invertX` Inverts Horizontal scrollbar position
     * - `invertAll` Inverts both scrollbar positions
     * @type {?}
     */
    NgScrollbar.prototype.position;
    /**
     * Debounce interval for detecting changes via ResizeObserver
     * @type {?}
     */
    NgScrollbar.prototype.sensorDebounce;
    /**
     * Whether ResizeObserver is disabled
     * @type {?}
     */
    NgScrollbar.prototype.sensorDisabled;
    /**
     * Steam that emits when scrollbar is updated
     * @type {?}
     */
    NgScrollbar.prototype.updated;
    /**
     * Viewport Element
     * @type {?}
     */
    NgScrollbar.prototype.viewport;
    /**
     * Content Wrapper element
     * @type {?}
     */
    NgScrollbar.prototype.contentWrapper;
    /**
     * stream that emits on scroll event
     * @type {?}
     */
    NgScrollbar.prototype.scrolled;
    /**
     * Steam that emits scroll event for vertical scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.verticalScrolled;
    /**
     * Steam that emits scroll event for horizontal scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.horizontalScrolled;
    /**
     * Default viewport classes
     * @type {?}
     */
    NgScrollbar.prototype.viewportClasses;
    /**
     * Set of attributes added on the scrollbar wrapper
     * @type {?}
     */
    NgScrollbar.prototype.state;
    /**
     * Stream that destroys components' observables
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.destroyed;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.dir;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.smoothScroll;
    /** @type {?} */
    NgScrollbar.prototype.manager;
    /** @type {?} */
    NgScrollbar.prototype.nativeScrollbarSizeFactory;
}
/**
 * @record
 */
function ScrollbarDragging() { }
if (false) {
    /** @type {?|undefined} */
    ScrollbarDragging.prototype.verticalDragging;
    /** @type {?|undefined} */
    ScrollbarDragging.prototype.horizontalDragging;
}
/**
 * @record
 */
function ScrollbarHovered() { }
if (false) {
    /** @type {?|undefined} */
    ScrollbarHovered.prototype.verticalHovered;
    /** @type {?|undefined} */
    ScrollbarHovered.prototype.horizontalHovered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ScrollbarRef {
    /**
     * @protected
     * @param {?} scrollbarRef
     * @param {?} document
     * @param {?} trackRef
     * @param {?} thumbRef
     * @param {?} platform
     * @param {?} destroyed
     */
    constructor(scrollbarRef, document, trackRef, thumbRef, platform, destroyed) {
        this.scrollbarRef = scrollbarRef;
        this.document = document;
        this.destroyed = destroyed;
        this.viewElement = scrollbarRef.viewport;
        this.trackElement = trackRef.nativeElement;
        this.thumbElement = thumbRef.nativeElement;
        if (!(platform.IOS || platform.ANDROID)) {
            this.pointerEvents = new Subject();
            this.hoveredState = new Subject();
            this.draggingState = new Subject();
            this.draggingState.pipe(distinctUntilChanged(), tap((/**
             * @param {?} state
             * @return {?}
             */
            (state) => this.setDragging(state))), takeUntil(this.destroyed)).subscribe();
            /** @type {?} */
            const scrollbarClicked = fromEvent(this.viewElement, 'mousedown', { passive: true }).pipe(switchMap((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.stopPropagation();
                this.document.onselectstart = (/**
                 * @return {?}
                 */
                () => false);
                /** @type {?} */
                const isThumbClick = isWithinBounds(e, this.thumbElement.getBoundingClientRect());
                if (isThumbClick && !coerceBooleanProperty(this.scrollbarRef.thumbDragDisabled)) {
                    return this.dragged(e);
                }
                else {
                    /** @type {?} */
                    const isTrackClick = isWithinBounds(e, this.trackElement.getBoundingClientRect());
                    if (isTrackClick && !coerceBooleanProperty(this.scrollbarRef.trackClickDisabled)) {
                        return this.trackClicked(e);
                    }
                }
                return EMPTY;
            })));
            // Activate/Deactivate scrollbar hover event
            /** @type {?} */
            const mouseLeave = fromEvent(this.viewElement, 'mouseleave').pipe(map((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.stopPropagation();
                return false;
            })));
            merge(this.pointerEvents, mouseLeave).pipe(distinctUntilChanged()).pipe(tap((/**
             * @param {?} state
             * @return {?}
             */
            (state) => this.setHovered(state))), takeUntil(this.destroyed)).subscribe();
            // Activate/Deactivate scrollTo on scrollbar click event
            this.pointerEvents.pipe(distinctUntilChanged(), switchMap((/**
             * @param {?} state
             * @return {?}
             */
            (state) => state ? scrollbarClicked : EMPTY)), takeUntil(this.destroyed)).subscribe();
            this.hovered().pipe(tap((/**
             * @param {?} state
             * @return {?}
             */
            (state) => this.pointerEvents.next(state))), takeUntil(this.destroyed)).subscribe();
        }
        // Start updating thumb position when view scrolls
        this.scrolled().pipe(tap((/**
         * @return {?}
         */
        () => this.updateThumb())), takeUntil(this.destroyed)).subscribe();
        // Update scrollbar when `NgScrollbar.update()` is called
        this.scrollbarRef.updated.pipe(tap((/**
         * @return {?}
         */
        () => this.updateThumb())), takeUntil(this.destroyed)).subscribe();
        // Initialize scrollbar
        asyncScheduler.schedule((/**
         * @return {?}
         */
        () => this.updateThumb()), 100);
    }
    // The available scrollable size
    /**
     * @protected
     * @return {?}
     */
    get scrollMax() {
        return this.scrollSize - this.viewportSize;
    }
    /**
     * @protected
     * @return {?}
     */
    get trackMax() {
        return this.trackSize - this.thumbSize;
    }
    /**
     * Updates scrollbar's thumb position and size
     * @protected
     * @return {?}
     */
    updateThumb() {
        /** @type {?} */
        const trackMax = this.trackMax;
        /** @type {?} */
        const size = calculateThumbSize(this.trackSize, this.scrollSize, this.scrollbarRef.minThumbSize);
        /** @type {?} */
        const position = calculateThumbPosition(this.scrollOffset, this.scrollMax, trackMax);
        animationFrameScheduler.schedule((/**
         * @return {?}
         */
        () => this.applyThumbStyle(size, position, trackMax)));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragged(event) {
        /** @type {?} */
        let trackMax;
        /** @type {?} */
        let scrollMax;
        /** @type {?} */
        const dragStart = of(event).pipe(tap((/**
         * @return {?}
         */
        () => {
            // Capture scrollMax and trackMax once
            trackMax = this.trackMax;
            scrollMax = this.scrollMax;
            this.draggingState.next(true);
        })));
        /** @type {?} */
        const dragging = fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => e.stopPropagation())));
        /** @type {?} */
        const dragEnd = fromEvent(this.document, 'mouseup', { capture: true }).pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            e.stopPropagation();
            this.document.onselectstart = null;
            this.draggingState.next(false);
        })));
        return dragStart.pipe(pluck(this.pageProperty), map((/**
         * @param {?} pageOffset
         * @return {?}
         */
        (pageOffset) => pageOffset - this.dragStartOffset)), mergeMap((/**
         * @param {?} mouseDownOffset
         * @return {?}
         */
        (mouseDownOffset) => dragging.pipe(pluck(this.clientProperty), 
        // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).
        map((/**
         * @param {?} mouseOffset
         * @return {?}
         */
        (mouseOffset) => mouseOffset - this.dragOffset)), map((/**
         * @param {?} offset
         * @return {?}
         */
        (offset) => scrollMax * (offset - mouseDownOffset) / trackMax)), map((/**
         * @param {?} position
         * @return {?}
         */
        (position) => this.handleDragPosition(position, scrollMax))), tap((/**
         * @param {?} value
         * @return {?}
         */
        (value) => this.scrollTo(value))), takeUntil(dragEnd)))));
    }
    /**
     * Stream that emits when a scrollbar is hovered
     * @private
     * @return {?}
     */
    hovered() {
        return fromEvent(this.viewElement, 'mousemove', { passive: true }).pipe(map((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            e.stopPropagation();
            return isWithinBounds(e, this.trackElement.getBoundingClientRect());
        })));
    }
    /**
     * Stream that emits when scrollbar track is clicked
     * @protected
     * @param {?} e
     * @return {?}
     */
    trackClicked(e) {
        return of(e).pipe(pluck(this.pageProperty), map((/**
         * @param {?} pageOffset
         * @return {?}
         */
        (pageOffset) => pageOffset - this.dragOffset)), map((/**
         * @param {?} clickOffset
         * @return {?}
         */
        (clickOffset) => {
            /** @type {?} */
            const offset = clickOffset - (this.thumbSize / 2);
            /** @type {?} */
            const ratio = offset / this.trackSize;
            return ratio * this.scrollSize;
        })), tap((/**
         * @param {?} value
         * @return {?}
         */
        (value) => this.scrollbarRef.scrollTo(Object.assign({}, this.mapToScrollToOption(value), { duration: coerceNumberProperty(this.scrollbarRef.trackClickScrollDuration) })))), tap((/**
         * @return {?}
         */
        () => this.document.onselectstart = null)));
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.viewElement;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.trackElement;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.thumbElement;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.hoveredState;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.draggingState;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.pointerEvents;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.scrollbarRef;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarRef.prototype.destroyed;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.scrollSize = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.viewportSize = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.trackSize = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.thumbSize = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.scrollOffset = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.dragStartOffset = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.dragOffset = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.pageProperty = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.clientProperty = function () { };
    /**
     * Stream that emits when view is scrolled
     * @abstract
     * @protected
     * @return {?}
     */
    ScrollbarRef.prototype.scrolled = function () { };
    /**
     * Return a scrollTo option parameter
     * @abstract
     * @protected
     * @param {?} value
     * @return {?}
     */
    ScrollbarRef.prototype.mapToScrollToOption = function (value) { };
    /**
     * Updates scrollbar's thumb size and position
     * @abstract
     * @protected
     * @param {?} size
     * @param {?} position
     * @param {?=} trackMax
     * @return {?}
     */
    ScrollbarRef.prototype.applyThumbStyle = function (size, position, trackMax) { };
    /**
     * On drag function
     * @abstract
     * @protected
     * @param {?} position
     * @param {?} scrollMax
     * @return {?}
     */
    ScrollbarRef.prototype.handleDragPosition = function (position, scrollMax) { };
    /**
     * @abstract
     * @protected
     * @param {?} point
     * @return {?}
     */
    ScrollbarRef.prototype.scrollTo = function (point) { };
    /**
     * @abstract
     * @protected
     * @param {?} value
     * @return {?}
     */
    ScrollbarRef.prototype.setDragging = function (value) { };
    /**
     * @abstract
     * @protected
     * @param {?} value
     * @return {?}
     */
    ScrollbarRef.prototype.setHovered = function (value) { };
}
/**
 * Calculate Scrollbar thumb size
 * @param {?} trackSize Scrollbar track size
 * @param {?} contentSize Content size or Viewport scroll size
 * @param {?} minThumbSize Minimum scrollbar thumb size
 * @return {?}
 */
function calculateThumbSize(trackSize, contentSize, minThumbSize) {
    /** @type {?} */
    const scrollbarRatio = trackSize / contentSize;
    /** @type {?} */
    const thumbSize = scrollbarRatio * trackSize;
    return Math.max(~~thumbSize, minThumbSize);
}
/**
 * Calculate scrollbar thumb position
 * @param {?} scrollPosition The scroll position of the viewport
 * @param {?} scrollMax The max size available to scroll the viewport
 * @param {?} trackMax The max size available to move scrollbar thumb
 * @return {?}
 */
function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
    return scrollPosition * trackMax / scrollMax;
}
/**
 * Check if pointer is within scrollbar bounds
 * @param {?} e Pointer event
 * @param {?} rect Scrollbar Client Rect
 * @return {?}
 */
function isWithinBounds(e, rect) {
    return (e.clientX >= rect.left &&
        e.clientX <= rect.left + rect.width &&
        e.clientY >= rect.top &&
        e.clientY <= rect.top + rect.height);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HorizontalScrollbarRef extends ScrollbarRef {
    /**
     * @param {?} scrollbarRef
     * @param {?} document
     * @param {?} trackRef
     * @param {?} thumbRef
     * @param {?} platform
     * @param {?} destroyed
     * @param {?} dir
     */
    constructor(scrollbarRef, document, trackRef, thumbRef, platform, destroyed, dir) {
        super(scrollbarRef, document, trackRef, thumbRef, platform, destroyed);
        this.scrollbarRef = scrollbarRef;
        this.document = document;
        this.platform = platform;
        this.destroyed = destroyed;
        this.dir = dir;
    }
    /**
     * @protected
     * @return {?}
     */
    get scrollSize() {
        return this.viewElement.scrollWidth;
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportSize() {
        return this.viewElement.clientWidth;
    }
    /**
     * @protected
     * @return {?}
     */
    get trackSize() {
        return this.trackElement.clientWidth;
    }
    /**
     * @protected
     * @return {?}
     */
    get thumbSize() {
        return this.thumbElement.clientWidth;
    }
    /**
     * @protected
     * @return {?}
     */
    get scrollOffset() {
        return this.viewElement.scrollLeft;
    }
    /**
     * @protected
     * @return {?}
     */
    get dragOffset() {
        return this.trackElement.getBoundingClientRect().left;
    }
    /**
     * @protected
     * @return {?}
     */
    get dragStartOffset() {
        return this.thumbElement.getBoundingClientRect().left;
    }
    /**
     * @protected
     * @return {?}
     */
    get pageProperty() {
        return 'pageX';
    }
    /**
     * @protected
     * @return {?}
     */
    get clientProperty() {
        return 'clientX';
    }
    /**
     * @private
     * @param {?} position
     * @param {?} trackMax
     * @return {?}
     */
    _handleThumbPosition(position, trackMax) {
        if (this.dir.value === 'rtl') {
            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return -position;
            }
            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
                return position - trackMax;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
            //   return position;
            // }
        }
        return position;
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    handleDragPosition(position) {
        if (this.dir.value === 'rtl') {
            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return position - this.scrollMax;
            }
            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return this.scrollMax - position;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
            //   return position;
            // }
        }
        return position;
    }
    /**
     * @protected
     * @return {?}
     */
    scrolled() {
        return this.scrollbarRef.horizontalScrolled;
    }
    /**
     * @protected
     * @param {?} size
     * @param {?} position
     * @param {?=} trackMax
     * @return {?}
     */
    applyThumbStyle(size, position, trackMax) {
        this.thumbElement.style.width = `${size}px`;
        this.thumbElement.style.transform = `translate3d(${this._handleThumbPosition(position, trackMax)}px, 0, 0)`;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    mapToScrollToOption(value) {
        return { left: value };
    }
    /**
     * @protected
     * @param {?} point
     * @return {?}
     */
    scrollTo(point) {
        this.viewElement.scrollLeft = point;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setHovered(value) {
        this.scrollbarRef.setHovered({ horizontalHovered: value });
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setDragging(value) {
        this.scrollbarRef.setDragging({ horizontalDragging: value });
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollbarRef.prototype.scrollbarRef;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollbarRef.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollbarRef.prototype.platform;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollbarRef.prototype.destroyed;
    /**
     * @type {?}
     * @protected
     */
    HorizontalScrollbarRef.prototype.dir;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VerticalScrollbarRef extends ScrollbarRef {
    /**
     * @param {?} scrollbarRef
     * @param {?} document
     * @param {?} trackRef
     * @param {?} thumbRef
     * @param {?} platform
     * @param {?} destroyed
     */
    constructor(scrollbarRef, document, trackRef, thumbRef, platform, destroyed) {
        super(scrollbarRef, document, trackRef, thumbRef, platform, destroyed);
        this.scrollbarRef = scrollbarRef;
        this.document = document;
        this.destroyed = destroyed;
    }
    /**
     * @protected
     * @return {?}
     */
    get scrollSize() {
        return this.viewElement.scrollHeight;
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportSize() {
        return this.viewElement.clientHeight;
    }
    /**
     * @protected
     * @return {?}
     */
    get trackSize() {
        return this.trackElement.clientHeight;
    }
    /**
     * @protected
     * @return {?}
     */
    get thumbSize() {
        return this.thumbElement.clientHeight;
    }
    /**
     * @protected
     * @return {?}
     */
    get scrollOffset() {
        return this.viewElement.scrollTop;
    }
    /**
     * @protected
     * @return {?}
     */
    get dragOffset() {
        return this.trackElement.getBoundingClientRect().top;
    }
    /**
     * @protected
     * @return {?}
     */
    get dragStartOffset() {
        return this.thumbElement.getBoundingClientRect().top;
    }
    /**
     * @protected
     * @return {?}
     */
    get pageProperty() {
        return 'pageY';
    }
    /**
     * @protected
     * @return {?}
     */
    get clientProperty() {
        return 'clientY';
    }
    /**
     * @protected
     * @return {?}
     */
    scrolled() {
        return this.scrollbarRef.verticalScrolled;
    }
    /**
     * @protected
     * @param {?} size
     * @param {?} position
     * @return {?}
     */
    applyThumbStyle(size, position) {
        this.thumbElement.style.height = `${size}px`;
        this.thumbElement.style.transform = `translate3d(0 ,${position}px, 0)`;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    mapToScrollToOption(value) {
        return { top: value };
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    handleDragPosition(position) {
        return position;
    }
    /**
     * @protected
     * @param {?} point
     * @return {?}
     */
    scrollTo(point) {
        this.viewElement.scrollTop = point;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setHovered(value) {
        this.scrollbarRef.setHovered({ verticalHovered: value });
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setDragging(value) {
        this.scrollbarRef.setDragging({ verticalDragging: value });
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollbarRef.prototype.scrollbarRef;
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollbarRef.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    VerticalScrollbarRef.prototype.destroyed;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollbarControl {
    /**
     * @param {?} parent
     * @param {?} platform
     * @param {?} dir
     * @param {?} zone
     * @param {?} document
     */
    constructor(parent, platform, dir, zone, document) {
        this.parent = parent;
        this.platform = platform;
        this.dir = dir;
        this.zone = zone;
        this.document = document;
        // Stream that emits to unsubscribe from all streams
        this.destroyed = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            // Avoid SSR Error
            if (this.platform.isBrowser) {
                this.scrollbarRef = this.track === 'vertical'
                    ? new VerticalScrollbarRef(this.parent, this.document, this.trackRef, this.thumbRef, this.platform, this.destroyed)
                    : new HorizontalScrollbarRef(this.parent, this.document, this.trackRef, this.thumbRef, this.platform, this.destroyed, this.dir);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed.next();
        this.destroyed.complete();
    }
}
ScrollbarControl.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ScrollbarControl, selectors: [["scrollbar-control"]], factory: function ScrollbarControl_Factory(t) { return new (t || ScrollbarControl)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(Platform), ɵngcc0.ɵɵdirectiveInject(Directionality), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); }, viewQuery: function ScrollbarControl_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
        ɵngcc0.ɵɵstaticViewQuery(_c12, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.trackRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.thumbRef = _t.first);
    } }, hostBindings: function ScrollbarControl_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("scrollbar-control", true);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { track: "track" }, consts: 4, vars: 4, template: function ScrollbarControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", null, _c13);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementStart(2, "div", null, _c14);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("ng-scrollbar-track ", ctx.parent.trackClass, "");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵclassMapInterpolate1("ng-scrollbar-thumb ", ctx.parent.thumbClass, "");
        ɵngcc0.ɵɵstylingApply();
    } }, styles: [".ng-scrollbar-thumb,   .ng-scrollbar-track,   .scrollbar-control{pointer-events:none}  .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:height 150ms ease-out,width 150ms ease-out}  .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}  .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:height 150ms ease-out,width 150ms ease-out;cursor:default}  .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:height 150ms ease-out,width 150ms ease-out}", ".ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]{height:var(--horizontal-scrollbar-total-size)}  .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}  .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}  .ng-scrollbar-wrapper[horizontalDragging=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[horizontalHovered=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[position=invertAll]>.scrollbar-control[track=horizontal],   .ng-scrollbar-wrapper[position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}  .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=horizontal]{left:0;right:0;bottom:0;top:unset}  .ng-scrollbar-wrapper[disabled=false][position=invertAll]>.scrollbar-control[track=horizontal],   .ng-scrollbar-wrapper[disabled=false][position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}  .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}  .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],   .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],   .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}", ".ng-scrollbar-wrapper>.scrollbar-control[track=vertical]{width:var(--vertical-scrollbar-total-size)}  .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}  .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}  .ng-scrollbar-wrapper[verticalDragging=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[verticalHovered=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=vertical]{top:0;bottom:0}  .ng-scrollbar-wrapper[disabled=false][dir=ltr]>.scrollbar-control[track=vertical]{right:0;left:unset}  .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertAll]>.scrollbar-control[track=vertical],   .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertY]>.scrollbar-control[track=vertical]{left:0;right:unset}  .ng-scrollbar-wrapper[disabled=false][dir=rtl]>.scrollbar-control[track=vertical]{left:0;right:unset}  .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertAll]>.scrollbar-control[track=vertical],   .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertY]>.scrollbar-control[track=vertical]{left:unset;right:0}  .ng-scrollbar-wrapper[disabled=false][track=all]>.scrollbar-control[track=vertical][fit=true]{bottom:var(--scrollbar-total-size);top:0}  .ng-scrollbar-wrapper[disabled=false][track=all][position=invertAll]>.scrollbar-control[track=vertical][fit=true],   .ng-scrollbar-wrapper[disabled=false][track=all][position=invertX]>.scrollbar-control[track=vertical][fit=true]{top:var(--scrollbar-total-size);bottom:0}"], changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ScrollbarControl, [{
        type: Component,
        args: [{
                selector: 'scrollbar-control',
                host: {
                    '[class.scrollbar-control]': 'true'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div #track class="ng-scrollbar-track {{parent.trackClass}}">
      <div #thumb class="ng-scrollbar-thumb {{parent.thumbClass}}"></div>
    </div>
  `,
                styles: ["::ng-deep .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-track,::ng-deep .scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:height 150ms ease-out,width 150ms ease-out}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:height 150ms ease-out,width 150ms ease-out;cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:height 150ms ease-out,width 150ms ease-out}", "::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>.scrollbar-control[track=horizontal],::ng-deep .ng-scrollbar-wrapper[position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=horizontal]{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][position=invertAll]>.scrollbar-control[track=horizontal],::ng-deep .ng-scrollbar-wrapper[disabled=false][position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}", "::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=vertical]{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr]>.scrollbar-control[track=vertical]{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertAll]>.scrollbar-control[track=vertical],::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertY]>.scrollbar-control[track=vertical]{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl]>.scrollbar-control[track=vertical]{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertAll]>.scrollbar-control[track=vertical],::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertY]>.scrollbar-control[track=vertical]{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all]>.scrollbar-control[track=vertical][fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][position=invertAll]>.scrollbar-control[track=vertical][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][position=invertX]>.scrollbar-control[track=vertical][fit=true]{top:var(--scrollbar-total-size);bottom:0}"]
            }]
    }], function () { return [{ type: NgScrollbar }, { type: Platform }, { type: Directionality }, { type: NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { constructor: [], parent: [], platform: [], dir: [], zone: [], document: [], destroyed: [], ngOnInit: [], scrollbarRef: [], ngOnDestroy: [], track: [{
            type: Input
        }], trackRef: [{
            type: ViewChild,
            args: ['track', { static: true }]
        }], thumbRef: [{
            type: ViewChild,
            args: ['thumb', { static: true }]
        }] });
/** @nocollapse */
ScrollbarControl.ctorParameters = () => [
    { type: NgScrollbar },
    { type: Platform },
    { type: Directionality },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
ScrollbarControl.propDecorators = {
    track: [{ type: Input }],
    trackRef: [{ type: ViewChild, args: ['track', { static: true },] }],
    thumbRef: [{ type: ViewChild, args: ['thumb', { static: true },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    ScrollbarControl.prototype.scrollbarRef;
    /**
     * @type {?}
     * @private
     */
    ScrollbarControl.prototype.track;
    /** @type {?} */
    ScrollbarControl.prototype.trackRef;
    /** @type {?} */
    ScrollbarControl.prototype.thumbRef;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarControl.prototype.destroyed;
    /** @type {?} */
    ScrollbarControl.prototype.parent;
    /**
     * @type {?}
     * @private
     */
    ScrollbarControl.prototype.platform;
    /**
     * @type {?}
     * @private
     */
    ScrollbarControl.prototype.dir;
    /**
     * @type {?}
     * @private
     */
    ScrollbarControl.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ScrollbarControl.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CssVariable {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * @param {?} size
     * @param {?} variableName
     * @return {?}
     */
    transform(size, variableName) {
        return this.sanitizer.bypassSecurityTrustStyle(`--${variableName}: -${size}px`);
    }
}
CssVariable.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "cssVariable", type: CssVariable, factory: function CssVariable_Factory(t) { return new (t || CssVariable)(ɵngcc0.ɵɵdirectiveInject(DomSanitizer)); }, pure: true });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(CssVariable, [{
        type: Pipe,
        args: [{
                name: 'cssVariable'
            }]
    }], function () { return [{ type: DomSanitizer }]; }, { constructor: [], sanitizer: [], transform: [] });
/** @nocollapse */
CssVariable.ctorParameters = () => [
    { type: DomSanitizer }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    CssVariable.prototype.sanitizer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgAttr {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @param {?} attrs
     * @return {?}
     */
    set ngAttr(attrs) {
        for (const [key, value] of Object.entries(attrs)) {
            ((/** @type {?} */ (this.el.nativeElement))).setAttribute(key, value);
        }
    }
}
NgAttr.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgAttr, selectors: [["", "ngAttr", ""]], factory: function NgAttr_Factory(t) { return new (t || NgAttr)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, inputs: { ngAttr: "ngAttr" } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgAttr, [{
        type: Directive,
        args: [{ selector: '[ngAttr]' }]
    }], function () { return [{ type: ElementRef }]; }, { constructor: [], el: [], ngAttr: [{
            type: Input
        }] });
/** @nocollapse */
NgAttr.ctorParameters = () => [
    { type: ElementRef }
];
NgAttr.propDecorators = {
    ngAttr: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgAttr.prototype.el;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Factory that initialize the ResizeObserver if available in the browser
 * Otherwise, it lazy-loads the ResizeObserver polyfill
 */
class ResizeObserverFactory {
    /**
     * @param {?} document
     * @param {?} platform
     */
    constructor(document, platform) {
        this.resizeObserverSource = new BehaviorSubject(null);
        this.resizeObserverLoader = this.resizeObserverSource.asObservable();
        if (platform.isBrowser) {
            /** @type {?} */
            const resizeObserverApi = document.defaultView.ResizeObserver
                ? of(document.defaultView.ResizeObserver)
                : from(import('@juggle/resize-observer')).pipe(map((/**
                 * @param {?} module
                 * @return {?}
                 */
                (module) => module.ResizeObserver)), catchError((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    console.log('Unable to load ResizeObserver polyfill', e);
                    return EMPTY;
                })));
            this.resizeObserverSource.next(resizeObserverApi);
        }
    }
}
ResizeObserverFactory.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: ResizeObserverFactory, factory: function ResizeObserverFactory_Factory(t) { return new (t || ResizeObserverFactory)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(Platform)); }, providedIn: 'root' });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ResizeObserverFactory, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: Platform }]; }, { constructor: [], resizeObserverSource: [], resizeObserverLoader: [] });
/** @nocollapse */
ResizeObserverFactory.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Platform }
];
/** @nocollapse */ ResizeObserverFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function ResizeObserverFactory_Factory() { return new ResizeObserverFactory(ɵɵinject(DOCUMENT), ɵɵinject(Platform)); }, token: ResizeObserverFactory, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ResizeObserverFactory.prototype.resizeObserverSource;
    /** @type {?} */
    ResizeObserverFactory.prototype.resizeObserverLoader;
}
class ResizeSensor {
    /**
     * @param {?} zone
     * @param {?} platform
     * @param {?} resizeObserverFactory
     * @param {?} scrollbar
     */
    constructor(zone, platform, resizeObserverFactory, scrollbar) {
        this.zone = zone;
        this.platform = platform;
        this.resizeObserverFactory = resizeObserverFactory;
        this.scrollbar = scrollbar;
        this._disabled = false;
        this._subscription = null;
        if (!scrollbar) {
            throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');
        }
    }
    /**
     * Debounce interval for emitting the changes.
     * @return {?}
     */
    get debounce() {
        return this._debounce;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set debounce(value) {
        this._debounce = coerceNumberProperty(value);
        this._subscribe();
    }
    /**
     * Whether ResizeObserver is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._disabled ? this._unsubscribe() : this._subscribe();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this._subscription && !this._disabled) {
            this._subscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe();
    }
    /**
     * @private
     * @param {?} ResizeObserver
     * @return {?}
     */
    _createObserver(ResizeObserver) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this._resizeObserver = new ResizeObserver((/**
             * @return {?}
             */
            () => observer.next()));
            this._resizeObserver.observe(this.scrollbar.viewport);
            if (this.scrollbar.contentWrapper) {
                this._resizeObserver.observe(this.scrollbar.contentWrapper);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _subscribe() {
        this._unsubscribe();
        if (this.platform.isBrowser) {
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this._subscription = this.resizeObserverFactory.resizeObserverLoader.pipe(switchMap((/**
                 * @param {?} moduleObservable
                 * @return {?}
                 */
                (moduleObservable) => moduleObservable)), switchMap((/**
                 * @param {?} ResizeObserver
                 * @return {?}
                 */
                (ResizeObserver) => {
                    if (ResizeObserver) {
                        /** @type {?} */
                        const stream = this._createObserver(ResizeObserver);
                        return this.debounce ? stream.pipe(debounceTime(this._debounce)) : stream;
                    }
                    else {
                        return EMPTY;
                    }
                }))).subscribe((/**
                 * @return {?}
                 */
                () => this.scrollbar.update()));
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    _unsubscribe() {
        if (this._resizeObserver) {
            this._resizeObserver.disconnect();
        }
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    }
}
ResizeSensor.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: ResizeSensor, selectors: [["", "resizeSensor", ""]], factory: function ResizeSensor_Factory(t) { return new (t || ResizeSensor)(ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(Platform), ɵngcc0.ɵɵdirectiveInject(ResizeObserverFactory), ɵngcc0.ɵɵdirectiveInject(NgScrollbar)); }, inputs: { debounce: ["sensorDebounce", "debounce"], disabled: ["sensorDisabled", "disabled"] } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ResizeSensor, [{
        type: Directive,
        args: [{ selector: '[resizeSensor]' }]
    }], function () { return [{ type: NgZone }, { type: Platform }, { type: ResizeObserverFactory }, { type: NgScrollbar }]; }, { constructor: [], zone: [], platform: [], resizeObserverFactory: [], scrollbar: [], _disabled: [], _subscription: [], debounce: [{
            type: Input,
            args: ['sensorDebounce']
        }], debounce: [], _debounce: [], disabled: [{
            type: Input,
            args: ['sensorDisabled']
        }], disabled: [], ngAfterContentInit: [], ngOnDestroy: [], _createObserver: [], _resizeObserver: [], _subscribe: [], _unsubscribe: [] });
/** @nocollapse */
ResizeSensor.ctorParameters = () => [
    { type: NgZone },
    { type: Platform },
    { type: ResizeObserverFactory },
    { type: NgScrollbar }
];
ResizeSensor.propDecorators = {
    debounce: [{ type: Input, args: ['sensorDebounce',] }],
    disabled: [{ type: Input, args: ['sensorDisabled',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._debounce;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._subscription;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._resizeObserver;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.platform;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.resizeObserverFactory;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.scrollbar;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarModule {
}
NgScrollbarModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: NgScrollbarModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(NgScrollbarModule, { declarations: function () { return [NgScrollbar,
        ScrollbarControl,
        ScrollViewport,
        CssVariable,
        NgAttr,
        ResizeSensor]; }, imports: function () { return [CommonModule,
        BidiModule,
        PortalModule,
        PlatformModule,
        SmoothScrollModule]; }, exports: function () { return [NgScrollbar,
        ScrollViewport]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgScrollbarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    BidiModule,
                    PortalModule,
                    PlatformModule,
                    SmoothScrollModule
                ],
                declarations: [
                    NgScrollbar,
                    ScrollbarControl,
                    ScrollViewport,
                    CssVariable,
                    NgAttr,
                    ResizeSensor
                ],
                exports: [
                    NgScrollbar,
                    ScrollViewport
                ]
            }]
    }], null, null);
NgScrollbarModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function NgScrollbarModule_Factory(t) { return new (t || NgScrollbarModule)(); }, imports: [[
            CommonModule,
            BidiModule,
            PortalModule,
            PlatformModule,
            SmoothScrollModule
        ]] });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarModule, ScrollViewport, ScrollbarManager, NativeScrollbarSizeFactory as ɵa, ScrollbarControl as ɵb, CssVariable as ɵc, NgAttr as ɵd, ResizeObserverFactory as ɵe, ResizeSensor as ɵf };

//# sourceMappingURL=ngx-scrollbar.js.map