{"version":3,"sources":["/home/nikola/Documents/Repos/ivy-bug/ngx-scroll-ivy-bug/ngx-scrollbar-bug/node_modules/ngx-scrollbar/fesm2015/ngx-scrollbar.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;CAOC,0FAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6KD,oFAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8DD,kNAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8TD,aAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4iCD,aAeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6ED,4GAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,aAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmDD,kHAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkJD,gJAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DD,aAuBC","file":"ngx-scrollbar.js","sourcesContent":["import { Directive, ElementRef, InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, ChangeDetectionStrategy, NgZone, ChangeDetectorRef, ViewChild, ContentChild, Input, Output, Pipe, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { PortalModule } from '@angular/cdk/portal';\nimport { getRtlScrollAxisType, Platform, RtlScrollAxisType, PlatformModule } from '@angular/cdk/platform';\nimport { SmoothScrollManager, SmoothScrollModule } from 'ngx-scrollbar/smooth-scroll';\nimport { of, BehaviorSubject, fromEvent, Subject, Observable, EMPTY, merge, asyncScheduler, animationFrameScheduler, from } from 'rxjs';\nimport { tap, switchMap, debounceTime, pluck, pairwise, filter, map, takeUntil, distinctUntilChanged, mergeMap, catchError } from 'rxjs/operators';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { DomSanitizer } from '@angular/platform-browser';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass ScrollViewport {\r\n    /**\r\n     * @param {?} viewPort\r\n     */\r\n    constructor(viewPort) {\r\n        this.viewPort = viewPort;\r\n    }\r\n}\r\nScrollViewport.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[scrollViewport], [scroll-viewport]',\r\n                host: {\r\n                    '[class.ng-scroll-viewport]': 'true'\r\n                }\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nScrollViewport.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\nif (false) {\r\n    /** @type {?} */\r\n    ScrollViewport.prototype.viewPort;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');\r\n/**\r\n * @record\r\n */\r\nfunction NgScrollbarOptions() { }\r\nif (false) {\r\n    /**\r\n     * Sets the scroll axis of the viewport, there are 3 options:\r\n     *\r\n     * - `vertical` Use both vertical and horizontal scrollbar-control\r\n     * - `horizontal` Use both vertical and horizontal scrollbar-control\r\n     * - `all` Use both vertical and horizontal scrollbar-control\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.track;\r\n    /**\r\n     * When to show the scrollbar, and there are 3 options:\r\n     *\r\n     * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar-control\r\n     * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering\r\n     * - `always` Scrollbars are always shown even if the viewport is not scrollable\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.visibility;\r\n    /**\r\n     *  Sets the appearance of the scrollbar, there are 2 options:\r\n     *\r\n     * - `standard` (default) scrollbar space will be reserved just like with native scrollbar-control.\r\n     * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.appearance;\r\n    /**\r\n     * Sets the position of each scrollbar, there are 4 options:\r\n     *\r\n     * - `native` (Default) Use the default position like in native scrollbar-control.\r\n     * - `invertY` Inverts vertical scrollbar position\r\n     * - `invertX` Inverts Horizontal scrollbar position\r\n     * - `invertAll` Inverts both scrollbar-control positions\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.position;\r\n    /**\r\n     * A class forwarded to scrollable viewport element\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.viewClass;\r\n    /**\r\n     * A class forwarded to the scrollbar track element\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.trackClass;\r\n    /**\r\n     * A class forwarded to the scrollbar thumb element\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.thumbClass;\r\n    /**\r\n     * The minimum scrollbar thumb size in px\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.minThumbSize;\r\n    /**\r\n     * The duration which the scrolling takes to reach its target when scrollbar rail is clicked\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.trackClickScrollDuration;\r\n    /**\r\n     * A flag used to enable/disable the scrollbar track clicked event\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.trackClickDisabled;\r\n    /**\r\n     * A flag used to enable/disable the scrollbar thumb dragged event\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.thumbDragDisabled;\r\n    /**\r\n     * Debounce interval for detecting changes via window.resize event\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.windowResizeDebounce;\r\n    /**\r\n     * Debounce interval for detecting changes via ResizeObserver\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.sensorDebounce;\r\n    /**\r\n     * Whether ResizeObserver is disabled\r\n     * @type {?|undefined}\r\n     */\r\n    NgScrollbarOptions.prototype.sensorDisabled;\r\n}\r\n/**\r\n * Set of attributes added on the scrollbar wrapper\r\n * @record\r\n */\r\nfunction NgScrollbarState() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.position;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.track;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.appearance;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.visibility;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.disabled;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.dir;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.verticalUsed;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.horizontalUsed;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.isVerticallyScrollable;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.isHorizontallyScrollable;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.verticalHovered;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.horizontalHovered;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.verticalDragging;\r\n    /** @type {?|undefined} */\r\n    NgScrollbarState.prototype.horizontalDragging;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst defaultOptions = {\r\n    viewClass: '',\r\n    trackClass: '',\r\n    thumbClass: '',\r\n    track: 'vertical',\r\n    appearance: 'compact',\r\n    visibility: 'native',\r\n    position: 'native',\r\n    thumbDragDisabled: false,\r\n    trackClickDisabled: false,\r\n    trackClickScrollDuration: 300,\r\n    minThumbSize: 20,\r\n    windowResizeDebounce: 0,\r\n    sensorDebounce: 0,\r\n    sensorDisabled: false\r\n};\r\nclass ScrollbarManager {\r\n    /**\r\n     * @param {?} options\r\n     */\r\n    constructor(options) {\r\n        this.globalOptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;\r\n        this.rtlScrollAxisType = getRtlScrollAxisType();\r\n    }\r\n}\r\nScrollbarManager.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] }\r\n];\r\n/** @nocollapse */\r\nScrollbarManager.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }\r\n];\r\n/** @nocollapse */ ScrollbarManager.ngInjectableDef = ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: \"root\" });\r\nif (false) {\r\n    /** @type {?} */\r\n    ScrollbarManager.prototype.globalOptions;\r\n    /** @type {?} */\r\n    ScrollbarManager.prototype.rtlScrollAxisType;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NativeScrollbarSizeFactory {\r\n    /**\r\n     * @param {?} document\r\n     * @param {?} manager\r\n     * @param {?} platform\r\n     */\r\n    constructor(document, manager, platform) {\r\n        this.document = document;\r\n        this.manager = manager;\r\n        this.platform = platform;\r\n        if (platform.isBrowser) {\r\n            of(null).pipe(tap((/**\r\n             * @return {?}\r\n             */\r\n            () => this._nativeScrollbarSize = new BehaviorSubject(this.getNativeScrollbarSize()))), tap((/**\r\n             * @return {?}\r\n             */\r\n            () => this.nativeScrollbarSize = this._nativeScrollbarSize.asObservable())), switchMap((/**\r\n             * @return {?}\r\n             */\r\n            () => fromEvent(this.document.defaultView, 'resize', { passive: true }))), debounceTime(this.manager.globalOptions.windowResizeDebounce), tap((/**\r\n             * @return {?}\r\n             */\r\n            () => this._nativeScrollbarSize.next(this.getNativeScrollbarSize())))).subscribe();\r\n        }\r\n    }\r\n    /**\r\n     * Get native scrollbar size\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    getNativeScrollbarSize() {\r\n        if (this.platform.ANDROID || this.platform.IOS) {\r\n            return 6;\r\n        }\r\n        /** @type {?} */\r\n        const box = this.document.createElement('div');\r\n        box.className = 'ng-scrollbar-measure';\r\n        this.document.body.appendChild(box);\r\n        /** @type {?} */\r\n        const size = box.getBoundingClientRect().right;\r\n        this.document.body.removeChild(box);\r\n        // if size is 0, return 15 (for MAC OS browsers)\r\n        return size || 15;\r\n    }\r\n}\r\nNativeScrollbarSizeFactory.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] }\r\n];\r\n/** @nocollapse */\r\nNativeScrollbarSizeFactory.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: ScrollbarManager },\r\n    { type: Platform }\r\n];\r\n/** @nocollapse */ NativeScrollbarSizeFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(ɵɵinject(DOCUMENT), ɵɵinject(ScrollbarManager), ɵɵinject(Platform)); }, token: NativeScrollbarSizeFactory, providedIn: \"root\" });\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NativeScrollbarSizeFactory.prototype._nativeScrollbarSize;\r\n    /** @type {?} */\r\n    NativeScrollbarSizeFactory.prototype.nativeScrollbarSize;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NativeScrollbarSizeFactory.prototype.document;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NativeScrollbarSizeFactory.prototype.manager;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NativeScrollbarSizeFactory.prototype.platform;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgScrollbar {\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} zone\r\n     * @param {?} changeDetectorRef\r\n     * @param {?} dir\r\n     * @param {?} smoothScroll\r\n     * @param {?} manager\r\n     * @param {?} nativeScrollbarSizeFactory\r\n     */\r\n    constructor(el, zone, changeDetectorRef, dir, smoothScroll, manager, nativeScrollbarSizeFactory) {\r\n        this.el = el;\r\n        this.zone = zone;\r\n        this.changeDetectorRef = changeDetectorRef;\r\n        this.dir = dir;\r\n        this.smoothScroll = smoothScroll;\r\n        this.manager = manager;\r\n        this.nativeScrollbarSizeFactory = nativeScrollbarSizeFactory;\r\n        /**\r\n         * A class forwarded to scrollable viewport element\r\n         */\r\n        this.viewClass = this.manager.globalOptions.viewClass;\r\n        /**\r\n         * A class forwarded to the scrollbar track element\r\n         */\r\n        this.trackClass = this.manager.globalOptions.trackClass;\r\n        /**\r\n         * A class forwarded to the scrollbar thumb element\r\n         */\r\n        this.thumbClass = this.manager.globalOptions.thumbClass;\r\n        /**\r\n         * Minimum scrollbar thumb size\r\n         */\r\n        this.minThumbSize = this.manager.globalOptions.minThumbSize;\r\n        /**\r\n         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked\r\n         */\r\n        this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;\r\n        /**\r\n         * A flag used to enable/disable the scrollbar track clicked event\r\n         */\r\n        this.trackClickDisabled = this.manager.globalOptions.trackClickDisabled;\r\n        /**\r\n         * A flag used to enable/disable the scrollbar thumb dragged event\r\n         */\r\n        this.thumbDragDisabled = this.manager.globalOptions.thumbDragDisabled;\r\n        /**\r\n         * Disable custom scrollbar and switch back to native scrollbar\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * Sets the supported scroll track of the viewport, there are 3 options:\r\n         *\r\n         * - `vertical` Use both vertical and horizontal scrollbar\r\n         * - `horizontal` Use both vertical and horizontal scrollbar\r\n         * - `all` Use both vertical and horizontal scrollbar\r\n         */\r\n        this.track = this.manager.globalOptions.track;\r\n        /**\r\n         * When to show the scrollbar, and there are 3 options:\r\n         *\r\n         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar\r\n         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering\r\n         * - `always` Scrollbars are always shown even if the viewport is not scrollable\r\n         */\r\n        this.visibility = this.manager.globalOptions.visibility;\r\n        /**\r\n         *  Sets the appearance of the scrollbar, there are 2 options:\r\n         *\r\n         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.\r\n         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.\r\n         */\r\n        this.appearance = this.manager.globalOptions.appearance;\r\n        /**\r\n         * Sets the position of each scrollbar, there are 4 options:\r\n         *\r\n         * - `native` (Default) Use the default position like in native scrollbar.\r\n         * - `invertY` Inverts vertical scrollbar position\r\n         * - `invertX` Inverts Horizontal scrollbar position\r\n         * - `invertAll` Inverts both scrollbar positions\r\n         */\r\n        this.position = this.manager.globalOptions.position;\r\n        /**\r\n         * Debounce interval for detecting changes via ResizeObserver\r\n         */\r\n        this.sensorDebounce = this.manager.globalOptions.sensorDebounce;\r\n        /**\r\n         * Whether ResizeObserver is disabled\r\n         */\r\n        this.sensorDisabled = this.manager.globalOptions.sensorDisabled;\r\n        /**\r\n         * Steam that emits when scrollbar is updated\r\n         */\r\n        this.updated = new EventEmitter();\r\n        /**\r\n         * Set of attributes added on the scrollbar wrapper\r\n         */\r\n        this.state = {};\r\n        /**\r\n         * Stream that destroys components' observables\r\n         */\r\n        this.destroyed = new Subject();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} track\r\n     * @return {?}\r\n     */\r\n    getScrolledByDirection(track) {\r\n        /** @type {?} */\r\n        const scrollProperty = track === 'vertical' ? 'scrollTop' : 'scrollLeft';\r\n        /** @type {?} */\r\n        let event;\r\n        return this.scrolled.pipe(tap((/**\r\n         * @param {?} e\r\n         * @return {?}\r\n         */\r\n        (e) => event = e)), pluck('target', scrollProperty), pairwise(), filter((/**\r\n         * @param {?} __0\r\n         * @return {?}\r\n         */\r\n        ([prev, curr]) => prev !== curr)), map((/**\r\n         * @return {?}\r\n         */\r\n        () => event)));\r\n    }\r\n    /**\r\n     * Update local state with each change detection\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    updateState() {\r\n        /** @type {?} */\r\n        let verticalUsed = false;\r\n        /** @type {?} */\r\n        let horizontalUsed = false;\r\n        /** @type {?} */\r\n        let isVerticallyScrollable = false;\r\n        /** @type {?} */\r\n        let isHorizontallyScrollable = false;\r\n        // Check if vertical scrollbar should be displayed\r\n        if (this.track === 'all' || this.track === 'vertical') {\r\n            isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;\r\n            verticalUsed = this.visibility === 'always' || isVerticallyScrollable;\r\n        }\r\n        // Check if horizontal scrollbar should be displayed\r\n        if (this.track === 'all' || this.track === 'horizontal') {\r\n            isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;\r\n            horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;\r\n        }\r\n        this._updateState({\r\n            position: this.position,\r\n            track: this.track,\r\n            appearance: this.appearance,\r\n            visibility: this.visibility,\r\n            disabled: this.disabled,\r\n            dir: this.dir.value,\r\n            verticalUsed,\r\n            horizontalUsed,\r\n            isVerticallyScrollable,\r\n            isHorizontallyScrollable\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} state\r\n     * @return {?}\r\n     */\r\n    _updateState(state) {\r\n        this.state = Object.assign({}, this.state, state);\r\n        this.changeDetectorRef.detectChanges();\r\n    }\r\n    /**\r\n     * @param {?} hovered\r\n     * @return {?}\r\n     */\r\n    setHovered(hovered) {\r\n        this.zone.run((/**\r\n         * @return {?}\r\n         */\r\n        () => this._updateState(Object.assign({}, hovered))));\r\n    }\r\n    /**\r\n     * @param {?} dragging\r\n     * @return {?}\r\n     */\r\n    setDragging(dragging) {\r\n        this.zone.run((/**\r\n         * @return {?}\r\n         */\r\n        () => this._updateState(Object.assign({}, dragging))));\r\n    }\r\n    /**\r\n     * Set the viewport based on user choice\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    setViewport() {\r\n        if (this.customViewPort) {\r\n            // Set the custom viewport as the scroll viewport\r\n            this.viewport = this.customViewPort.viewPort.nativeElement;\r\n            // In this case the default viewport and the default content wrapper will act as a mask\r\n            this.viewportClasses = {\r\n                'ng-scroll-offset': true,\r\n                'ng-scroll-layer': true\r\n            };\r\n            this.defaultViewPort.nativeElement.firstElementChild.className = 'ng-scroll-layer';\r\n        }\r\n        else {\r\n            // Set the default viewport as the scroll viewport\r\n            this.viewport = this.defaultViewPort.nativeElement;\r\n            this.viewportClasses = {\r\n                'ng-scroll-offset': true,\r\n                'ng-scroll-viewport': true,\r\n                [this.viewClass]: true,\r\n            };\r\n        }\r\n        // Check if the custom viewport has only one child and set it as the content wrapper\r\n        if (this.viewport.firstElementChild) {\r\n            this.contentWrapper = (/** @type {?} */ (this.viewport.firstElementChild));\r\n            this.contentWrapper.classList.add('ng-scroll-content');\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        this.zone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this.setViewport();\r\n            // Initialize scroll streams\r\n            this.scrolled = new Observable((/**\r\n             * @param {?} observer\r\n             * @return {?}\r\n             */\r\n            (observer) => fromEvent(this.viewport, 'scroll', { passive: true }).pipe(takeUntil(this.destroyed))\r\n                .subscribe(observer)));\r\n            this.verticalScrolled = this.getScrolledByDirection('vertical');\r\n            this.horizontalScrolled = this.getScrolledByDirection('horizontal');\r\n        }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterViewChecked() {\r\n        this.updateState();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this.destroyed.next();\r\n        this.destroyed.complete();\r\n    }\r\n    /**\r\n     * Update local state and the internal scrollbar controls\r\n     * @return {?}\r\n     */\r\n    update() {\r\n        this.updated.next();\r\n        this.changeDetectorRef.detectChanges();\r\n    }\r\n    /**\r\n     * Smooth scroll functions\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    scrollTo(options) {\r\n        return this.smoothScroll.scrollTo(this.viewport, options);\r\n    }\r\n    /**\r\n     * Scroll to element by reference or selector\r\n     * @param {?} target\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    scrollToElement(target, options) {\r\n        return this.smoothScroll.scrollToElement(this.viewport, target, options);\r\n    }\r\n}\r\nNgScrollbar.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'ng-scrollbar',\r\n                exportAs: 'ngScrollbar',\r\n                template: \"<div class=\\\"ng-scrollbar-wrapper\\\" [ngAttr]=\\\"state\\\">\\r\\n  <div class=\\\"ng-scroll-viewport-wrapper\\\"\\r\\n       resizeSensor\\r\\n       [sensorDebounce]=\\\"sensorDebounce\\\"\\r\\n       [sensorDisabled]=\\\"sensorDisabled\\\">\\r\\n    <div #viewport\\r\\n         [ngClass]=\\\"viewportClasses\\\"\\r\\n         [style]=\\\"nativeScrollbarSizeFactory.nativeScrollbarSize | async | cssVariable: 'native-scrollbar-size'\\\">\\r\\n      <div>\\r\\n        <ng-content></ng-content>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n  <ng-container *ngIf=\\\"!disabled\\\">\\r\\n    <scrollbar-control *ngIf=\\\"state.verticalUsed\\\"\\r\\n                       track=\\\"vertical\\\"\\r\\n                       [attr.scrollable]=\\\"state.isVerticallyScrollable\\\"\\r\\n                       [attr.fit]=\\\"state.horizontalUsed\\\">\\r\\n    </scrollbar-control>\\r\\n    <scrollbar-control *ngIf=\\\"state.horizontalUsed\\\"\\r\\n                       track=\\\"horizontal\\\"\\r\\n                       [attr.scrollable]=\\\"state.isHorizontallyScrollable\\\"\\r\\n                       [attr.fit]=\\\"state.verticalUsed\\\">\\r\\n    </scrollbar-control>\\r\\n  </ng-container>\\r\\n</div>\\r\\n\\r\\n\",\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { '[class.ng-scrollbar]': 'true' },\r\n                styles: [\"::ng-deep .ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);display:block;position:relative;height:100%}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertAll]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[disabled=false][appearance=standard][horizontalUsed=true][position=invertX]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[disabled=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-scroll-offset{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[disabled=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:.4s;transition-delay:0s}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-ms-scroll-chaining:contain contain;overscroll-behavior:contain contain;-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}\"]\r\n            }] }\r\n];\r\n/** @nocollapse */\r\nNgScrollbar.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: ChangeDetectorRef },\r\n    { type: Directionality },\r\n    { type: SmoothScrollManager },\r\n    { type: ScrollbarManager },\r\n    { type: NativeScrollbarSizeFactory }\r\n];\r\nNgScrollbar.propDecorators = {\r\n    defaultViewPort: [{ type: ViewChild, args: ['viewport', { static: true },] }],\r\n    customViewPort: [{ type: ContentChild, args: [ScrollViewport, { static: true },] }],\r\n    viewClass: [{ type: Input }],\r\n    trackClass: [{ type: Input }],\r\n    thumbClass: [{ type: Input }],\r\n    minThumbSize: [{ type: Input }],\r\n    trackClickScrollDuration: [{ type: Input }],\r\n    trackClickDisabled: [{ type: Input }],\r\n    thumbDragDisabled: [{ type: Input }],\r\n    disabled: [{ type: Input }],\r\n    track: [{ type: Input }],\r\n    visibility: [{ type: Input }],\r\n    appearance: [{ type: Input }],\r\n    position: [{ type: Input }],\r\n    sensorDebounce: [{ type: Input }],\r\n    sensorDisabled: [{ type: Input }],\r\n    updated: [{ type: Output }]\r\n};\r\nif (false) {\r\n    /**\r\n     * Default viewport reference\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.defaultViewPort;\r\n    /**\r\n     * Custom viewport reference\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.customViewPort;\r\n    /**\r\n     * A class forwarded to scrollable viewport element\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.viewClass;\r\n    /**\r\n     * A class forwarded to the scrollbar track element\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.trackClass;\r\n    /**\r\n     * A class forwarded to the scrollbar thumb element\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.thumbClass;\r\n    /**\r\n     * Minimum scrollbar thumb size\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.minThumbSize;\r\n    /**\r\n     * The duration which the scrolling takes to reach its target when scrollbar rail is clicked\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.trackClickScrollDuration;\r\n    /**\r\n     * A flag used to enable/disable the scrollbar track clicked event\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.trackClickDisabled;\r\n    /**\r\n     * A flag used to enable/disable the scrollbar thumb dragged event\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.thumbDragDisabled;\r\n    /**\r\n     * Disable custom scrollbar and switch back to native scrollbar\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.disabled;\r\n    /**\r\n     * Sets the supported scroll track of the viewport, there are 3 options:\r\n     *\r\n     * - `vertical` Use both vertical and horizontal scrollbar\r\n     * - `horizontal` Use both vertical and horizontal scrollbar\r\n     * - `all` Use both vertical and horizontal scrollbar\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.track;\r\n    /**\r\n     * When to show the scrollbar, and there are 3 options:\r\n     *\r\n     * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar\r\n     * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering\r\n     * - `always` Scrollbars are always shown even if the viewport is not scrollable\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.visibility;\r\n    /**\r\n     *  Sets the appearance of the scrollbar, there are 2 options:\r\n     *\r\n     * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.\r\n     * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.appearance;\r\n    /**\r\n     * Sets the position of each scrollbar, there are 4 options:\r\n     *\r\n     * - `native` (Default) Use the default position like in native scrollbar.\r\n     * - `invertY` Inverts vertical scrollbar position\r\n     * - `invertX` Inverts Horizontal scrollbar position\r\n     * - `invertAll` Inverts both scrollbar positions\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.position;\r\n    /**\r\n     * Debounce interval for detecting changes via ResizeObserver\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.sensorDebounce;\r\n    /**\r\n     * Whether ResizeObserver is disabled\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.sensorDisabled;\r\n    /**\r\n     * Steam that emits when scrollbar is updated\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.updated;\r\n    /**\r\n     * Viewport Element\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.viewport;\r\n    /**\r\n     * Content Wrapper element\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.contentWrapper;\r\n    /**\r\n     * stream that emits on scroll event\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.scrolled;\r\n    /**\r\n     * Steam that emits scroll event for vertical scrollbar\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.verticalScrolled;\r\n    /**\r\n     * Steam that emits scroll event for horizontal scrollbar\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.horizontalScrolled;\r\n    /**\r\n     * Default viewport classes\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.viewportClasses;\r\n    /**\r\n     * Set of attributes added on the scrollbar wrapper\r\n     * @type {?}\r\n     */\r\n    NgScrollbar.prototype.state;\r\n    /**\r\n     * Stream that destroys components' observables\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.destroyed;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.el;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.zone;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.changeDetectorRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.dir;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgScrollbar.prototype.smoothScroll;\r\n    /** @type {?} */\r\n    NgScrollbar.prototype.manager;\r\n    /** @type {?} */\r\n    NgScrollbar.prototype.nativeScrollbarSizeFactory;\r\n}\r\n/**\r\n * @record\r\n */\r\nfunction ScrollbarDragging() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    ScrollbarDragging.prototype.verticalDragging;\r\n    /** @type {?|undefined} */\r\n    ScrollbarDragging.prototype.horizontalDragging;\r\n}\r\n/**\r\n * @record\r\n */\r\nfunction ScrollbarHovered() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    ScrollbarHovered.prototype.verticalHovered;\r\n    /** @type {?|undefined} */\r\n    ScrollbarHovered.prototype.horizontalHovered;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @abstract\r\n */\r\nclass ScrollbarRef {\r\n    /**\r\n     * @protected\r\n     * @param {?} scrollbarRef\r\n     * @param {?} document\r\n     * @param {?} trackRef\r\n     * @param {?} thumbRef\r\n     * @param {?} platform\r\n     * @param {?} destroyed\r\n     */\r\n    constructor(scrollbarRef, document, trackRef, thumbRef, platform, destroyed) {\r\n        this.scrollbarRef = scrollbarRef;\r\n        this.document = document;\r\n        this.destroyed = destroyed;\r\n        this.viewElement = scrollbarRef.viewport;\r\n        this.trackElement = trackRef.nativeElement;\r\n        this.thumbElement = thumbRef.nativeElement;\r\n        if (!(platform.IOS || platform.ANDROID)) {\r\n            this.pointerEvents = new Subject();\r\n            this.hoveredState = new Subject();\r\n            this.draggingState = new Subject();\r\n            this.draggingState.pipe(distinctUntilChanged(), tap((/**\r\n             * @param {?} state\r\n             * @return {?}\r\n             */\r\n            (state) => this.setDragging(state))), takeUntil(this.destroyed)).subscribe();\r\n            /** @type {?} */\r\n            const scrollbarClicked = fromEvent(this.viewElement, 'mousedown', { passive: true }).pipe(switchMap((/**\r\n             * @param {?} e\r\n             * @return {?}\r\n             */\r\n            (e) => {\r\n                e.stopPropagation();\r\n                this.document.onselectstart = (/**\r\n                 * @return {?}\r\n                 */\r\n                () => false);\r\n                /** @type {?} */\r\n                const isThumbClick = isWithinBounds(e, this.thumbElement.getBoundingClientRect());\r\n                if (isThumbClick && !coerceBooleanProperty(this.scrollbarRef.thumbDragDisabled)) {\r\n                    return this.dragged(e);\r\n                }\r\n                else {\r\n                    /** @type {?} */\r\n                    const isTrackClick = isWithinBounds(e, this.trackElement.getBoundingClientRect());\r\n                    if (isTrackClick && !coerceBooleanProperty(this.scrollbarRef.trackClickDisabled)) {\r\n                        return this.trackClicked(e);\r\n                    }\r\n                }\r\n                return EMPTY;\r\n            })));\r\n            // Activate/Deactivate scrollbar hover event\r\n            /** @type {?} */\r\n            const mouseLeave = fromEvent(this.viewElement, 'mouseleave').pipe(map((/**\r\n             * @param {?} e\r\n             * @return {?}\r\n             */\r\n            (e) => {\r\n                e.stopPropagation();\r\n                return false;\r\n            })));\r\n            merge(this.pointerEvents, mouseLeave).pipe(distinctUntilChanged()).pipe(tap((/**\r\n             * @param {?} state\r\n             * @return {?}\r\n             */\r\n            (state) => this.setHovered(state))), takeUntil(this.destroyed)).subscribe();\r\n            // Activate/Deactivate scrollTo on scrollbar click event\r\n            this.pointerEvents.pipe(distinctUntilChanged(), switchMap((/**\r\n             * @param {?} state\r\n             * @return {?}\r\n             */\r\n            (state) => state ? scrollbarClicked : EMPTY)), takeUntil(this.destroyed)).subscribe();\r\n            this.hovered().pipe(tap((/**\r\n             * @param {?} state\r\n             * @return {?}\r\n             */\r\n            (state) => this.pointerEvents.next(state))), takeUntil(this.destroyed)).subscribe();\r\n        }\r\n        // Start updating thumb position when view scrolls\r\n        this.scrolled().pipe(tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this.updateThumb())), takeUntil(this.destroyed)).subscribe();\r\n        // Update scrollbar when `NgScrollbar.update()` is called\r\n        this.scrollbarRef.updated.pipe(tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this.updateThumb())), takeUntil(this.destroyed)).subscribe();\r\n        // Initialize scrollbar\r\n        asyncScheduler.schedule((/**\r\n         * @return {?}\r\n         */\r\n        () => this.updateThumb()), 100);\r\n    }\r\n    // The available scrollable size\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get scrollMax() {\r\n        return this.scrollSize - this.viewportSize;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get trackMax() {\r\n        return this.trackSize - this.thumbSize;\r\n    }\r\n    /**\r\n     * Updates scrollbar's thumb position and size\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    updateThumb() {\r\n        /** @type {?} */\r\n        const trackMax = this.trackMax;\r\n        /** @type {?} */\r\n        const size = calculateThumbSize(this.trackSize, this.scrollSize, this.scrollbarRef.minThumbSize);\r\n        /** @type {?} */\r\n        const position = calculateThumbPosition(this.scrollOffset, this.scrollMax, trackMax);\r\n        animationFrameScheduler.schedule((/**\r\n         * @return {?}\r\n         */\r\n        () => this.applyThumbStyle(size, position, trackMax)));\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    dragged(event) {\r\n        /** @type {?} */\r\n        let trackMax;\r\n        /** @type {?} */\r\n        let scrollMax;\r\n        /** @type {?} */\r\n        const dragStart = of(event).pipe(tap((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // Capture scrollMax and trackMax once\r\n            trackMax = this.trackMax;\r\n            scrollMax = this.scrollMax;\r\n            this.draggingState.next(true);\r\n        })));\r\n        /** @type {?} */\r\n        const dragging = fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(tap((/**\r\n         * @param {?} e\r\n         * @return {?}\r\n         */\r\n        (e) => e.stopPropagation())));\r\n        /** @type {?} */\r\n        const dragEnd = fromEvent(this.document, 'mouseup', { capture: true }).pipe(tap((/**\r\n         * @param {?} e\r\n         * @return {?}\r\n         */\r\n        (e) => {\r\n            e.stopPropagation();\r\n            this.document.onselectstart = null;\r\n            this.draggingState.next(false);\r\n        })));\r\n        return dragStart.pipe(pluck(this.pageProperty), map((/**\r\n         * @param {?} pageOffset\r\n         * @return {?}\r\n         */\r\n        (pageOffset) => pageOffset - this.dragStartOffset)), mergeMap((/**\r\n         * @param {?} mouseDownOffset\r\n         * @return {?}\r\n         */\r\n        (mouseDownOffset) => dragging.pipe(pluck(this.clientProperty), \r\n        // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\r\n        map((/**\r\n         * @param {?} mouseOffset\r\n         * @return {?}\r\n         */\r\n        (mouseOffset) => mouseOffset - this.dragOffset)), map((/**\r\n         * @param {?} offset\r\n         * @return {?}\r\n         */\r\n        (offset) => scrollMax * (offset - mouseDownOffset) / trackMax)), map((/**\r\n         * @param {?} position\r\n         * @return {?}\r\n         */\r\n        (position) => this.handleDragPosition(position, scrollMax))), tap((/**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        (value) => this.scrollTo(value))), takeUntil(dragEnd)))));\r\n    }\r\n    /**\r\n     * Stream that emits when a scrollbar is hovered\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    hovered() {\r\n        return fromEvent(this.viewElement, 'mousemove', { passive: true }).pipe(map((/**\r\n         * @param {?} e\r\n         * @return {?}\r\n         */\r\n        (e) => {\r\n            e.stopPropagation();\r\n            return isWithinBounds(e, this.trackElement.getBoundingClientRect());\r\n        })));\r\n    }\r\n    /**\r\n     * Stream that emits when scrollbar track is clicked\r\n     * @protected\r\n     * @param {?} e\r\n     * @return {?}\r\n     */\r\n    trackClicked(e) {\r\n        return of(e).pipe(pluck(this.pageProperty), map((/**\r\n         * @param {?} pageOffset\r\n         * @return {?}\r\n         */\r\n        (pageOffset) => pageOffset - this.dragOffset)), map((/**\r\n         * @param {?} clickOffset\r\n         * @return {?}\r\n         */\r\n        (clickOffset) => {\r\n            /** @type {?} */\r\n            const offset = clickOffset - (this.thumbSize / 2);\r\n            /** @type {?} */\r\n            const ratio = offset / this.trackSize;\r\n            return ratio * this.scrollSize;\r\n        })), tap((/**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        (value) => this.scrollbarRef.scrollTo(Object.assign({}, this.mapToScrollToOption(value), { duration: coerceNumberProperty(this.scrollbarRef.trackClickScrollDuration) })))), tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this.document.onselectstart = null)));\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.viewElement;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.trackElement;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.thumbElement;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.hoveredState;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.draggingState;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.pointerEvents;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.scrollbarRef;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.document;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarRef.prototype.destroyed;\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.scrollSize = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.viewportSize = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.trackSize = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.thumbSize = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.scrollOffset = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.dragStartOffset = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.dragOffset = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.pageProperty = function () { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.clientProperty = function () { };\r\n    /**\r\n     * Stream that emits when view is scrolled\r\n     * @abstract\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.scrolled = function () { };\r\n    /**\r\n     * Return a scrollTo option parameter\r\n     * @abstract\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.mapToScrollToOption = function (value) { };\r\n    /**\r\n     * Updates scrollbar's thumb size and position\r\n     * @abstract\r\n     * @protected\r\n     * @param {?} size\r\n     * @param {?} position\r\n     * @param {?=} trackMax\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.applyThumbStyle = function (size, position, trackMax) { };\r\n    /**\r\n     * On drag function\r\n     * @abstract\r\n     * @protected\r\n     * @param {?} position\r\n     * @param {?} scrollMax\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.handleDragPosition = function (position, scrollMax) { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @param {?} point\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.scrollTo = function (point) { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.setDragging = function (value) { };\r\n    /**\r\n     * @abstract\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    ScrollbarRef.prototype.setHovered = function (value) { };\r\n}\r\n/**\r\n * Calculate Scrollbar thumb size\r\n * @param {?} trackSize Scrollbar track size\r\n * @param {?} contentSize Content size or Viewport scroll size\r\n * @param {?} minThumbSize Minimum scrollbar thumb size\r\n * @return {?}\r\n */\r\nfunction calculateThumbSize(trackSize, contentSize, minThumbSize) {\r\n    /** @type {?} */\r\n    const scrollbarRatio = trackSize / contentSize;\r\n    /** @type {?} */\r\n    const thumbSize = scrollbarRatio * trackSize;\r\n    return Math.max(~~thumbSize, minThumbSize);\r\n}\r\n/**\r\n * Calculate scrollbar thumb position\r\n * @param {?} scrollPosition The scroll position of the viewport\r\n * @param {?} scrollMax The max size available to scroll the viewport\r\n * @param {?} trackMax The max size available to move scrollbar thumb\r\n * @return {?}\r\n */\r\nfunction calculateThumbPosition(scrollPosition, scrollMax, trackMax) {\r\n    return scrollPosition * trackMax / scrollMax;\r\n}\r\n/**\r\n * Check if pointer is within scrollbar bounds\r\n * @param {?} e Pointer event\r\n * @param {?} rect Scrollbar Client Rect\r\n * @return {?}\r\n */\r\nfunction isWithinBounds(e, rect) {\r\n    return (e.clientX >= rect.left &&\r\n        e.clientX <= rect.left + rect.width &&\r\n        e.clientY >= rect.top &&\r\n        e.clientY <= rect.top + rect.height);\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass HorizontalScrollbarRef extends ScrollbarRef {\r\n    /**\r\n     * @param {?} scrollbarRef\r\n     * @param {?} document\r\n     * @param {?} trackRef\r\n     * @param {?} thumbRef\r\n     * @param {?} platform\r\n     * @param {?} destroyed\r\n     * @param {?} dir\r\n     */\r\n    constructor(scrollbarRef, document, trackRef, thumbRef, platform, destroyed, dir) {\r\n        super(scrollbarRef, document, trackRef, thumbRef, platform, destroyed);\r\n        this.scrollbarRef = scrollbarRef;\r\n        this.document = document;\r\n        this.platform = platform;\r\n        this.destroyed = destroyed;\r\n        this.dir = dir;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get scrollSize() {\r\n        return this.viewElement.scrollWidth;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get viewportSize() {\r\n        return this.viewElement.clientWidth;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get trackSize() {\r\n        return this.trackElement.clientWidth;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get thumbSize() {\r\n        return this.thumbElement.clientWidth;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get scrollOffset() {\r\n        return this.viewElement.scrollLeft;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get dragOffset() {\r\n        return this.trackElement.getBoundingClientRect().left;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get dragStartOffset() {\r\n        return this.thumbElement.getBoundingClientRect().left;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get pageProperty() {\r\n        return 'pageX';\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get clientProperty() {\r\n        return 'clientX';\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} position\r\n     * @param {?} trackMax\r\n     * @return {?}\r\n     */\r\n    _handleThumbPosition(position, trackMax) {\r\n        if (this.dir.value === 'rtl') {\r\n            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {\r\n                return -position;\r\n            }\r\n            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {\r\n                return position - trackMax;\r\n            }\r\n            // Keeping this as a memo\r\n            // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {\r\n            //   return position;\r\n            // }\r\n        }\r\n        return position;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} position\r\n     * @return {?}\r\n     */\r\n    handleDragPosition(position) {\r\n        if (this.dir.value === 'rtl') {\r\n            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {\r\n                return position - this.scrollMax;\r\n            }\r\n            if (this.scrollbarRef.manager.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {\r\n                return this.scrollMax - position;\r\n            }\r\n            // Keeping this as a memo\r\n            // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {\r\n            //   return position;\r\n            // }\r\n        }\r\n        return position;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    scrolled() {\r\n        return this.scrollbarRef.horizontalScrolled;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} size\r\n     * @param {?} position\r\n     * @param {?=} trackMax\r\n     * @return {?}\r\n     */\r\n    applyThumbStyle(size, position, trackMax) {\r\n        this.thumbElement.style.width = `${size}px`;\r\n        this.thumbElement.style.transform = `translate3d(${this._handleThumbPosition(position, trackMax)}px, 0, 0)`;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    mapToScrollToOption(value) {\r\n        return { left: value };\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} point\r\n     * @return {?}\r\n     */\r\n    scrollTo(point) {\r\n        this.viewElement.scrollLeft = point;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setHovered(value) {\r\n        this.scrollbarRef.setHovered({ horizontalHovered: value });\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setDragging(value) {\r\n        this.scrollbarRef.setDragging({ horizontalDragging: value });\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    HorizontalScrollbarRef.prototype.scrollbarRef;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    HorizontalScrollbarRef.prototype.document;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    HorizontalScrollbarRef.prototype.platform;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    HorizontalScrollbarRef.prototype.destroyed;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    HorizontalScrollbarRef.prototype.dir;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass VerticalScrollbarRef extends ScrollbarRef {\r\n    /**\r\n     * @param {?} scrollbarRef\r\n     * @param {?} document\r\n     * @param {?} trackRef\r\n     * @param {?} thumbRef\r\n     * @param {?} platform\r\n     * @param {?} destroyed\r\n     */\r\n    constructor(scrollbarRef, document, trackRef, thumbRef, platform, destroyed) {\r\n        super(scrollbarRef, document, trackRef, thumbRef, platform, destroyed);\r\n        this.scrollbarRef = scrollbarRef;\r\n        this.document = document;\r\n        this.destroyed = destroyed;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get scrollSize() {\r\n        return this.viewElement.scrollHeight;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get viewportSize() {\r\n        return this.viewElement.clientHeight;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get trackSize() {\r\n        return this.trackElement.clientHeight;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get thumbSize() {\r\n        return this.thumbElement.clientHeight;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get scrollOffset() {\r\n        return this.viewElement.scrollTop;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get dragOffset() {\r\n        return this.trackElement.getBoundingClientRect().top;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get dragStartOffset() {\r\n        return this.thumbElement.getBoundingClientRect().top;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get pageProperty() {\r\n        return 'pageY';\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    get clientProperty() {\r\n        return 'clientY';\r\n    }\r\n    /**\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    scrolled() {\r\n        return this.scrollbarRef.verticalScrolled;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} size\r\n     * @param {?} position\r\n     * @return {?}\r\n     */\r\n    applyThumbStyle(size, position) {\r\n        this.thumbElement.style.height = `${size}px`;\r\n        this.thumbElement.style.transform = `translate3d(0 ,${position}px, 0)`;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    mapToScrollToOption(value) {\r\n        return { top: value };\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} position\r\n     * @return {?}\r\n     */\r\n    handleDragPosition(position) {\r\n        return position;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} point\r\n     * @return {?}\r\n     */\r\n    scrollTo(point) {\r\n        this.viewElement.scrollTop = point;\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setHovered(value) {\r\n        this.scrollbarRef.setHovered({ verticalHovered: value });\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setDragging(value) {\r\n        this.scrollbarRef.setDragging({ verticalDragging: value });\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    VerticalScrollbarRef.prototype.scrollbarRef;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    VerticalScrollbarRef.prototype.document;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    VerticalScrollbarRef.prototype.destroyed;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass ScrollbarControl {\r\n    /**\r\n     * @param {?} parent\r\n     * @param {?} platform\r\n     * @param {?} dir\r\n     * @param {?} zone\r\n     * @param {?} document\r\n     */\r\n    constructor(parent, platform, dir, zone, document) {\r\n        this.parent = parent;\r\n        this.platform = platform;\r\n        this.dir = dir;\r\n        this.zone = zone;\r\n        this.document = document;\r\n        // Stream that emits to unsubscribe from all streams\r\n        this.destroyed = new Subject();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        this.zone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // Avoid SSR Error\r\n            if (this.platform.isBrowser) {\r\n                this.scrollbarRef = this.track === 'vertical'\r\n                    ? new VerticalScrollbarRef(this.parent, this.document, this.trackRef, this.thumbRef, this.platform, this.destroyed)\r\n                    : new HorizontalScrollbarRef(this.parent, this.document, this.trackRef, this.thumbRef, this.platform, this.destroyed, this.dir);\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this.destroyed.next();\r\n        this.destroyed.complete();\r\n    }\r\n}\r\nScrollbarControl.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'scrollbar-control',\r\n                host: {\r\n                    '[class.scrollbar-control]': 'true'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                template: `\r\n    <div #track class=\"ng-scrollbar-track {{parent.trackClass}}\">\r\n      <div #thumb class=\"ng-scrollbar-thumb {{parent.thumbClass}}\"></div>\r\n    </div>\r\n  `,\r\n                styles: [\"::ng-deep .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-track,::ng-deep .scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:height 150ms ease-out,width 150ms ease-out}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:height 150ms ease-out,width 150ms ease-out;cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:height 150ms ease-out,width 150ms ease-out}\", \"::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=horizontal]>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>.scrollbar-control[track=horizontal] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>.scrollbar-control[track=horizontal],::ng-deep .ng-scrollbar-wrapper[position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=horizontal]{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][position=invertAll]>.scrollbar-control[track=horizontal],::ng-deep .ng-scrollbar-wrapper[disabled=false][position=invertX]>.scrollbar-control[track=horizontal]{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=ltr][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl]>.scrollbar-control[track=horizontal][fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertAll]>.scrollbar-control[track=horizontal][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][dir=rtl][position=invertY]>.scrollbar-control[track=horizontal][fit=true]{right:var(--scrollbar-total-size);left:0}\", \"::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[track=vertical]>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>.scrollbar-control[track=vertical] .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[disabled=false]>.scrollbar-control[track=vertical]{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr]>.scrollbar-control[track=vertical]{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertAll]>.scrollbar-control[track=vertical],::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=ltr][position=invertY]>.scrollbar-control[track=vertical]{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl]>.scrollbar-control[track=vertical]{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertAll]>.scrollbar-control[track=vertical],::ng-deep .ng-scrollbar-wrapper[disabled=false][dir=rtl][position=invertY]>.scrollbar-control[track=vertical]{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all]>.scrollbar-control[track=vertical][fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][position=invertAll]>.scrollbar-control[track=vertical][fit=true],::ng-deep .ng-scrollbar-wrapper[disabled=false][track=all][position=invertX]>.scrollbar-control[track=vertical][fit=true]{top:var(--scrollbar-total-size);bottom:0}\"]\r\n            }] }\r\n];\r\n/** @nocollapse */\r\nScrollbarControl.ctorParameters = () => [\r\n    { type: NgScrollbar },\r\n    { type: Platform },\r\n    { type: Directionality },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\nScrollbarControl.propDecorators = {\r\n    track: [{ type: Input }],\r\n    trackRef: [{ type: ViewChild, args: ['track', { static: true },] }],\r\n    thumbRef: [{ type: ViewChild, args: ['thumb', { static: true },] }]\r\n};\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ScrollbarControl.prototype.scrollbarRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ScrollbarControl.prototype.track;\r\n    /** @type {?} */\r\n    ScrollbarControl.prototype.trackRef;\r\n    /** @type {?} */\r\n    ScrollbarControl.prototype.thumbRef;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    ScrollbarControl.prototype.destroyed;\r\n    /** @type {?} */\r\n    ScrollbarControl.prototype.parent;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ScrollbarControl.prototype.platform;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ScrollbarControl.prototype.dir;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ScrollbarControl.prototype.zone;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ScrollbarControl.prototype.document;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass CssVariable {\r\n    /**\r\n     * @param {?} sanitizer\r\n     */\r\n    constructor(sanitizer) {\r\n        this.sanitizer = sanitizer;\r\n    }\r\n    /**\r\n     * @param {?} size\r\n     * @param {?} variableName\r\n     * @return {?}\r\n     */\r\n    transform(size, variableName) {\r\n        return this.sanitizer.bypassSecurityTrustStyle(`--${variableName}: -${size}px`);\r\n    }\r\n}\r\nCssVariable.decorators = [\r\n    { type: Pipe, args: [{\r\n                name: 'cssVariable'\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nCssVariable.ctorParameters = () => [\r\n    { type: DomSanitizer }\r\n];\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    CssVariable.prototype.sanitizer;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgAttr {\r\n    /**\r\n     * @param {?} el\r\n     */\r\n    constructor(el) {\r\n        this.el = el;\r\n    }\r\n    /**\r\n     * @param {?} attrs\r\n     * @return {?}\r\n     */\r\n    set ngAttr(attrs) {\r\n        for (const [key, value] of Object.entries(attrs)) {\r\n            ((/** @type {?} */ (this.el.nativeElement))).setAttribute(key, value);\r\n        }\r\n    }\r\n}\r\nNgAttr.decorators = [\r\n    { type: Directive, args: [{ selector: '[ngAttr]' },] }\r\n];\r\n/** @nocollapse */\r\nNgAttr.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\nNgAttr.propDecorators = {\r\n    ngAttr: [{ type: Input }]\r\n};\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgAttr.prototype.el;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Factory that initialize the ResizeObserver if available in the browser\r\n * Otherwise, it lazy-loads the ResizeObserver polyfill\r\n */\r\nclass ResizeObserverFactory {\r\n    /**\r\n     * @param {?} document\r\n     * @param {?} platform\r\n     */\r\n    constructor(document, platform) {\r\n        this.resizeObserverSource = new BehaviorSubject(null);\r\n        this.resizeObserverLoader = this.resizeObserverSource.asObservable();\r\n        if (platform.isBrowser) {\r\n            /** @type {?} */\r\n            const resizeObserverApi = document.defaultView.ResizeObserver\r\n                ? of(document.defaultView.ResizeObserver)\r\n                : from(import('@juggle/resize-observer')).pipe(map((/**\r\n                 * @param {?} module\r\n                 * @return {?}\r\n                 */\r\n                (module) => module.ResizeObserver)), catchError((/**\r\n                 * @param {?} e\r\n                 * @return {?}\r\n                 */\r\n                (e) => {\r\n                    console.log('Unable to load ResizeObserver polyfill', e);\r\n                    return EMPTY;\r\n                })));\r\n            this.resizeObserverSource.next(resizeObserverApi);\r\n        }\r\n    }\r\n}\r\nResizeObserverFactory.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] }\r\n];\r\n/** @nocollapse */\r\nResizeObserverFactory.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: Platform }\r\n];\r\n/** @nocollapse */ ResizeObserverFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function ResizeObserverFactory_Factory() { return new ResizeObserverFactory(ɵɵinject(DOCUMENT), ɵɵinject(Platform)); }, token: ResizeObserverFactory, providedIn: \"root\" });\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeObserverFactory.prototype.resizeObserverSource;\r\n    /** @type {?} */\r\n    ResizeObserverFactory.prototype.resizeObserverLoader;\r\n}\r\nclass ResizeSensor {\r\n    /**\r\n     * @param {?} zone\r\n     * @param {?} platform\r\n     * @param {?} resizeObserverFactory\r\n     * @param {?} scrollbar\r\n     */\r\n    constructor(zone, platform, resizeObserverFactory, scrollbar) {\r\n        this.zone = zone;\r\n        this.platform = platform;\r\n        this.resizeObserverFactory = resizeObserverFactory;\r\n        this.scrollbar = scrollbar;\r\n        this._disabled = false;\r\n        this._subscription = null;\r\n        if (!scrollbar) {\r\n            throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');\r\n        }\r\n    }\r\n    /**\r\n     * Debounce interval for emitting the changes.\r\n     * @return {?}\r\n     */\r\n    get debounce() {\r\n        return this._debounce;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set debounce(value) {\r\n        this._debounce = coerceNumberProperty(value);\r\n        this._subscribe();\r\n    }\r\n    /**\r\n     * Whether ResizeObserver is disabled.\r\n     * @return {?}\r\n     */\r\n    get disabled() {\r\n        return this._disabled;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n        this._disabled ? this._unsubscribe() : this._subscribe();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        if (!this._subscription && !this._disabled) {\r\n            this._subscribe();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._unsubscribe();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} ResizeObserver\r\n     * @return {?}\r\n     */\r\n    _createObserver(ResizeObserver) {\r\n        return new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        (observer) => {\r\n            this._resizeObserver = new ResizeObserver((/**\r\n             * @return {?}\r\n             */\r\n            () => observer.next()));\r\n            this._resizeObserver.observe(this.scrollbar.viewport);\r\n            if (this.scrollbar.contentWrapper) {\r\n                this._resizeObserver.observe(this.scrollbar.contentWrapper);\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _subscribe() {\r\n        this._unsubscribe();\r\n        if (this.platform.isBrowser) {\r\n            this.zone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this._subscription = this.resizeObserverFactory.resizeObserverLoader.pipe(switchMap((/**\r\n                 * @param {?} moduleObservable\r\n                 * @return {?}\r\n                 */\r\n                (moduleObservable) => moduleObservable)), switchMap((/**\r\n                 * @param {?} ResizeObserver\r\n                 * @return {?}\r\n                 */\r\n                (ResizeObserver) => {\r\n                    if (ResizeObserver) {\r\n                        /** @type {?} */\r\n                        const stream = this._createObserver(ResizeObserver);\r\n                        return this.debounce ? stream.pipe(debounceTime(this._debounce)) : stream;\r\n                    }\r\n                    else {\r\n                        return EMPTY;\r\n                    }\r\n                }))).subscribe((/**\r\n                 * @return {?}\r\n                 */\r\n                () => this.scrollbar.update()));\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _unsubscribe() {\r\n        if (this._resizeObserver) {\r\n            this._resizeObserver.disconnect();\r\n        }\r\n        if (this._subscription) {\r\n            this._subscription.unsubscribe();\r\n        }\r\n    }\r\n}\r\nResizeSensor.decorators = [\r\n    { type: Directive, args: [{ selector: '[resizeSensor]' },] }\r\n];\r\n/** @nocollapse */\r\nResizeSensor.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: Platform },\r\n    { type: ResizeObserverFactory },\r\n    { type: NgScrollbar }\r\n];\r\nResizeSensor.propDecorators = {\r\n    debounce: [{ type: Input, args: ['sensorDebounce',] }],\r\n    disabled: [{ type: Input, args: ['sensorDisabled',] }]\r\n};\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype._debounce;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype._disabled;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype._subscription;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype._resizeObserver;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype.zone;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype.platform;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype.resizeObserverFactory;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ResizeSensor.prototype.scrollbar;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgScrollbarModule {\r\n}\r\nNgScrollbarModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    BidiModule,\r\n                    PortalModule,\r\n                    PlatformModule,\r\n                    SmoothScrollModule\r\n                ],\r\n                declarations: [\r\n                    NgScrollbar,\r\n                    ScrollbarControl,\r\n                    ScrollViewport,\r\n                    CssVariable,\r\n                    NgAttr,\r\n                    ResizeSensor\r\n                ],\r\n                exports: [\r\n                    NgScrollbar,\r\n                    ScrollViewport\r\n                ]\r\n            },] }\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarModule, ScrollViewport, ScrollbarManager, NativeScrollbarSizeFactory as ɵa, ScrollbarControl as ɵb, CssVariable as ɵc, NgAttr as ɵd, ResizeObserverFactory as ɵe, ResizeSensor as ɵf };\n"]}